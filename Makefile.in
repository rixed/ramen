# Configuration

VERSION = @PACKAGE_VERSION@
BUNDLE_DIR = bundle

DUPS_IN  = $(shell ocamlfind query compiler-libs)
OCAMLOPT = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamlopt
OCAMLDEP = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamldep
QTEST    = qtest
Z3       = /usr/bin/z3
WARNS    = -w -40-58+27

override OCAMLOPTFLAGS += -thread -I src -I $(BUNDLE_DIR)/lib $(WARNS) -g -annot -S
override CFLAGS        += -std=gnu11   -g -O2 -Wall -W -Wno-parentheses -fPIC
override CXXFLAGS      += -std=gnu++17 -g -O2 -Wall -W -Wno-parentheses -fPIC
override CPPFLAGS      += -D_GNU_SOURCE \
                          -I $(shell ocamlfind ocamlc -where) \
                          -I $(BUNDLE_DIR)/include \
                          -DHAVE_INT128 -I $(shell ocamlfind query stdint)

ifdef NDEBUG
OCAMLOPTFLAGS += -noassert -O2
CPPFLAGS += -DNDEBUG -O2
endif

# parsercombinator is used by string to IP conversion :(
META_REQUIRES = \
	findlib batteries stdint parsercombinator threads \
	binocle lacaml ppp ppp.unix syslog
# The above are the dependencies required when ramen is running.
# To build ramen you will also need:
#   unix num js_of_ocaml js_of_ocaml-ppx cmdliner sqlite3
#   compiler-libs compiler-libs.common
#   compiler-libs.bytecomp compiler-libs.optcomp

PACKAGES = \
	ppp ppp.ppx ppp.unix batteries cmdliner stdint parsercombinator \
	syslog num binocle unix lacaml \
	compiler-libs compiler-libs.common compiler-libs.bytecomp \
	compiler-libs.optcomp net_codecs sqlite3

ifeq ($(shell uname),Darwin)
FILE_NOTIFIER = src/RamenFileNotify_Poller.ml
else
FILE_NOTIFIER = src/RamenFileNotify_Inotify.ml
META_REQUIRES += inotify
PACKAGES += inotify
endif

INSTALLED_BIN = src/ramen
INSTALLED_LIB = \
	src/codegen.cmxa src/codegen.a \
	$(CODEGENLIB_SOURCES:.ml=.cmi) $(CODEGENLIB_SOURCES:.ml=.cmx) \
	src/libringbuf.a src/libcollectd.a src/libnetflow.a \
	src/liborchelp.a
INSTALLED = $(INSTALLED_BIN) $(INSTALLED_LIB) META

prefix = @prefix@
exec_prefix = @exec_prefix@
bin_dir ?= @bindir@
# Where the deb (or other non-opam) version of ramen will get the libraries
# bundle from. This is important that the ramen package is compiled with the
# correct path as we use opam installed libs to build the non-opam bundle,
# or RamenCompilConfig will be incompatible).
lib_dir ?= /usr/lib/ramen

# Where examples are installed
sample_dir ?= /var/lib/ramen

# Where to install systemd configuration
systemd_dir ?= /lib/systemd/system
sysconf_dir ?= /etc/default

all: $(INSTALLED) bundle

# Generic rules

.SUFFIXES: .ml .mli .mlppp .cmi .cmx .cmxs .cmt .top .html .adoc .ramen .x .test .success
.PHONY: clean clean-temp all dep bundle doc deb tarball bundle \
        check func-check unit-check cli-check err-check arc-check orc-check \
        install install-bundle install-examples install-systemd uninstall reinstall \
        docker-latest docker-build-image docker-build-builder docker-circleci docker-push

%.cmi: %.mli
	@echo 'Compiling $@ (interface)'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c $<

%.cmx %.cmt: %.ml
	@echo 'Compiling $@'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c $<

%.mlppp: %.ml
	@echo 'Generating preprocessed sources for $<'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -dsource -c $< 2> $@

# Documentation

%.html: %.adoc
	@echo 'Building documentation $@'
	@asciidoc -a data-uri -a icons -a toc -a max-width=55em --theme volnitsky -o $@ $<

doc: docs/tutorial.html docs/manual.html docs/roadmap.html

docs/tutorial.html: docs/tutorial_group_by.svg docs/sample_chart1.svg

# Dependencies

RAMEN_SOURCES = \
	src/RamenVersions.ml \
	src/RamenAtomic.ml \
	src/RamenNullable.ml \
	src/RamenLog.ml \
	src/RamenHelpers.ml \
	src/RamenBitmask.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenCollectd.ml \
	src/RamenNetflow.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenLang.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenBinocle.ml \
	src/RamenNotification.ml \
	src/RamenExpr.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenOutRef.ml \
	src/RamenConf.ml \
	src/RamenSerialization.ml \
	src/RamenTypingHelpers.ml \
	src/RamenProgram.ml \
	src/RamenWatchdog.ml \
	src/HeavyHitters.ml \
	src/Globs.ml \
	src/RamenCompilConfig.ml \
	src/RamenDepLibs.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenTypingErrors.ml \
	src/RamenTyping.ml \
	src/RamenCompiler.ml \
	src/RamenMake.ml \
	src/RamenProcesses.ml \
	src/RamenPs.ml \
	src/RamenArchivist.ml \
	src/RamenExport.ml \
	src/RamenTimeseries.ml \
	src/RamenHttpHelpers.ml \
	src/RamenGc.ml \
	src/RamenRun.ml \
	src/RamenGraphite.ml \
	src/RamenApi.ml \
	src/RamenHeap.ml \
	src/RamenSzHeap.ml \
	src/SqliteHelpers.ml \
	src/RamenAlerter.ml \
	src/TermTable.ml \
	src/RamenHttpd.ml \
	src/RamenCopySrv.ml \
	src/RamenCliCmd.ml \
	src/RingBufCmd.ml \
	src/RamenCompletion.ml \
	src/RamenTests.ml \
	src/ramen.ml

CODEGENLIB_SOURCES = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenNullable.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/Globs.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenFiles.ml \
	src/RamenWatchdog.ml \
	src/RamenAdvLock.ml \
	src/RamenFieldMask.ml \
	src/RamenOutRef.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenCollectd.ml \
	src/RamenNetflow.ml \
	src/RamenGraphiteSink.ml \
	src/RingBuf.ml \
	src/RamenTypeConverters.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenBinocle.ml \
	src/RamenNotification.ml \
	src/RamenBloomFilter.ml \
	src/RamenSampling.ml \
	src/RamenFileNotify.ml \
	src/CodeGenLib_IO.ml \
	src/CodeGenLib_State.ml \
	src/CodeGenLib_Casing.ml \
	src/RamenHeap.ml \
	src/RamenSzHeap.ml \
	src/RamenSortBuf.ml \
	src/RamenCopyClt.ml \
	src/CodeGenLib_Skeletons.ml \
	src/HeavyHitters.ml \
	src/CodeGenLib.ml

LIBRINGBUF_SOURCES = \
	src/ringbuf/archive.h \
	src/ringbuf/archive.c \
	src/ringbuf/ringbuf.h \
	src/ringbuf/ringbuf.c \
	src/ringbuf/wrappers.c

LIBCOLLECTD_SOURCES = \
	src/collectd/collectd.h \
	src/collectd/collectd.c \
	src/collectd/wrappers.c

LIBNETFLOW_SOURCES = \
	src/netflow/v5.c

LIBORC_SOURCES = src/orc/wrappers.cc

ORCWRITER_SOURCES = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenNullable.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/Globs.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenCollectd.ml \
	src/RamenNetflow.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenLang.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenBinocle.ml \
	src/RamenNotification.ml \
	src/RamenExpr.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenOutRef.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenConf.ml \
	src/RamenSerialization.ml \
	src/RamenCompilConfig.ml \
	src/RamenDepLibs.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenTypingErrors.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenCompiler.ml \
	src/orc/orc_writer.ml

TESTONLY_SOURCES = \
	src/TestHelpers.ml

SOURCES = \
	$(RAMEN_SOURCES) $(CODEGENLIB_SOURCES) \
	$(LIBRINGBUF_SOURCES) $(LIBRINGBUF_OCAML_SOURCES) \
	$(LIBCOLLECTD_SOURCES) $(LIBNETFLOW_SOURCES) \
	$(ORCWRITER_SOURCES) $(LIBORC_SOURCES) $(TESTONLY_SOURCES) \
	src/ringbuf_test.ml

dep:
	@$(RM) .depend
	@$(MAKE) .depend

.depend: $(SOURCES)
	@$(OCAMLDEP) -native -I src -package "$(PACKAGES)" $(filter %.ml, $(SOURCES)) $(filter %.mli, $(SOURCES)) > $@
	@for f in $(filter %.c, $(SOURCES)); do \
	  $(CC) $(CPPFLAGS) -MM -MT "$$(dirname $$f)/$$(basename $$f .c).o" $$f >> $@; \
	done

include .depend

# Compile Ramen

src/RamenFileNotify.ml: $(FILE_NOTIFIER)
	@echo 'Using implementation $(FILE_NOTIFIER) for new file notifications'
	@ln -sf $(notdir $<) $@
	@touch $@

src/libringbuf.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBRINGBUF_SOURCES)))
	@echo 'Building ringbuf library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

src/libcollectd.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBCOLLECTD_SOURCES)))
	@echo 'Building collectd library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

src/libnetflow.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBNETFLOW_SOURCES)))
	@echo 'Building netflow library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

src/liborchelp.a: $(patsubst %.cc,%.o,$(filter %.cc, $(LIBORC_SOURCES)))
	@echo 'Building orc helper library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

submodules/orc/NOTICE: .gitmodules
	@echo "Getting submodules"
	@git submodule init
	@git submodule update
	@touch $@

# We need the ORC include files to be installed for that one:
src/orc/wrappers.o: $(BUNDLE_DIR)/lib/liborc.a

$(BUNDLE_DIR)/lib/liborc.a: $(BUNDLE_DIR)/date submodules/orc/NOTICE
	@echo 'Building liborc'
	@mkdir -p submodules/orc/build
	@cd submodules/orc/build &&\
	 cmake .. -DBUILD_JAVA=OFF -DCMAKE_BUILD_TYPE=DEBUG -DCMAKE_INSTALL_PREFIX:PATH=$(PWD)/$(BUNDLE_DIR) &&\
	 make install
	@touch $@

# We have to force -cclib -lstdint_stubs right after -cclib wrap_ringbuf.o
# otherwise -package stdint would put it before and gcc would not include the
# symbols we need as we are the only users.
MOREFLAGS = \
	-package "$(PACKAGES)" \
	-cclib -lstdint_stubs \
	-cclib -lorchelp \
	-cclib -lringbuf \
	-cclib -lcollectd \
	-cclib -lnetflow \
	-cclib -lorc \
	-cclib -lhdfspp_static \
	-cclib -llz4 \
	-cclib -lprotobuf \
	-cclib -lzstd \
	-cclib -lsnappy \
	-cclib -lz \
	-cclib -lsasl2 \
	-cclib -lcrypto \
	-cclib -lstdc++

src/orc/orc_writer: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(ORCWRITER_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter %.ml, $(ORCWRITER_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a
	@echo 'Linking $@'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

orc-check: src/orc/orc_writer $(wildcard tests/orc/*.type) $(wildcard tests/orc/*.data)
	@echo 'Checking ORC writes...'
	@failed="" ;\
	 for t in $(wildcard tests/orc/*.type); do \
	   base="$$(basename $$t .type)" ;\
	   echo "  Checking $$base" ;\
	   typ=$$(cat "$$t") ;\
	   data="$$(dirname $$t)/$$base.data" ;\
	   writer="/tmp/$$base" ;\
	   orc="/tmp/$$base.orc" ;\
	   csv="/tmp/$$base.csv" ;\
	   if ! (\
	     src/orc/orc_writer "$$writer" "$$typ" &&\
	     "$$writer" write "$$orc" < "$$data" &&\
	     "$$writer" read  "$$orc" > "$$csv" ;\
	   ) then \
	     echo "\033[1;31mFAILURE\033[0m: Cannot create CSV file for $$base" ;\
	     failed="$$failed $$base" ;\
	   else \
	     if diff -q "$$data" "$$csv"; then \
	       echo "\033[1;32mSUCCESS\033[0m" ;\
	     else \
	       echo "\033[1;31mFAILURE\033[0m: $$data and $$csv differ:" ;\
	       diff "$$data" "$$csv" ;\
	       failed="$$failed $$base" ;\
	     fi ;\
	   fi ;\
	 done ;\
	 if test -n "$$failed"; then \
	   echo "\033[1;31mFAILURE\033[0m:$$failed" ;\
	   exit 1 ;\
	 fi

src/ramen: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(RAMEN_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter %.ml, $(RAMEN_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a
	@echo 'Linking $@'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/codegen.cmxa: \
		$(CODEGENLIB_SOURCES:.ml=.cmx) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a
	@echo 'Linking runtime library $@'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -a $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/codegen.a: src/codegen.cmxa

# embedded compiler version: build a bundle of all libraries
OCAML_WHERE = $(shell dirname $(shell ocamlfind ocamlc -where))
# cut -c X- means to takes all from X, 1st char being 1, thus the leading _:
OCAML_WHERE_LEN = $(shell printf '_%s/' $(OCAML_WHERE) | wc -m | xargs echo)

META:
	@echo 'Building findlib configuration (META) for Ramen'
	@echo 'description = "Event processor tailored for small-scale monitoring"' > $@
	@echo 'version = "$(VERSION)"' >> $@
	@echo 'archive(native) = "codegen.cmxa"' >> $@
	@echo 'requires = "$(META_REQUIRES)"' >> $@

bundle: $(BUNDLE_DIR)/ramen/codegen.a $(BUNDLE_DIR)/lib/liborc.a

$(BUNDLE_DIR)/date:
	@echo '!!! REBUILDING $(BUNDLE_DIR) !!!'
	@$(RM) -rf '$(BUNDLE_DIR)'
	@mkdir -p '$(BUNDLE_DIR)'
	@touch $@

$(BUNDLE_DIR)/ramen/codegen.a: $(BUNDLE_DIR)/date $(INSTALLED_LIB)
	@echo 'Bundling libs together into $(BUNDLE_DIR)'
	@$(RM) -rf '$(BUNDLE_DIR).tmp'
	@mkdir '$(BUNDLE_DIR).tmp'
	@set -e ;\
	 deps=$$( \
	   for p in $(META_REQUIRES) ; do \
	     ocamlfind query -recursive -predicates native -format '%d' $$p ;\
	   done | sort -u | grep -v /findlib) ;\
	 for d in $$deps ; do cp -r "$$d" '$(BUNDLE_DIR).tmp/' ; done
	@mkdir $(BUNDLE_DIR).tmp/ramen
	@cp $(INSTALLED_LIB) $(BUNDLE_DIR).tmp/ramen
	@find '$(BUNDLE_DIR).tmp' -type f -not '-(' \
	    -name '*.cmx*' -o -name '*.cmi' -o -name '*.a' -o \
	    -name '*.so' -o -name '*.o' \
	  '-)' -delete
	@find '$(BUNDLE_DIR).tmp' -empty -delete
	@# Delete some of the biggest unused files:
	@$(RM) $(BUNDLE_DIR).tmp/batteries/batteriesExceptionless.cm*
	@$(RM) -r $(BUNDLE_DIR).tmp/ocaml/compiler-libs
	@$(RM) -r $(BUNDLE_DIR).tmp/ocaml/camlp4
	@$(RM) -r $(BUNDLE_DIR).tmp/ocaml/ocamldoc
	@$(RM) -r $(BUNDLE_DIR).tmp/ocaml/thread
	@$(RM) -r $(BUNDLE_DIR).tmp/ocaml/ocplib*
	@$(RM) $(BUNDLE_DIR).tmp/ocaml/camlinternalFormat.*
	@$(RM) $(BUNDLE_DIR).tmp/ocaml/*spacetime*
	@# to clear a clang warning:
	@mkdir $(BUNDLE_DIR).tmp/num
	@mkdir $(BUNDLE_DIR).tmp/bytes
	@# Delete everything that's not from liborc:
	@mkdir -p '$(BUNDLE_DIR)'
	@find '$(BUNDLE_DIR)' -maxdepth 1 -mindepth 1 -type d -not '-(' \
	    -name lib -o -name include \
		'-)' -exec rm -rf '{}' \;
	@mv $(BUNDLE_DIR).tmp/* $(BUNDLE_DIR)/
	@$(RM) -r $(BUNDLE_DIR).tmp
	@touch $@

# Bootstrapping this is a bit special as ocamlfind needs to know the ramen
# package first. Therefore this file is included with the source package for
# simplicity.
src/RamenDepLibs.ml.frominst:
	@echo '(* Generated by Makefile - edition is futile *)' > $@
	@echo 'module N = RamenName' >> $@
	@echo 'let incdirs = [' >> $@
	@set -e ; for d in $$(ocamlfind query -recursive -predicates native -format '%d' ramen | sort -u | grep -v -e compiler-libs -e ppx_tools -e /findlib) ; do \
	  echo $$d | cut -c $(OCAML_WHERE_LEN)- | \
	  sed -e 's,^\(.*\)$$,  N.path "\1" ;,' >> $@ ;\
	done ;
# Equivalent to -threads:
	@echo '  N.path "ocaml/threads" ;' >> $@
	@echo ']' >> $@
	@echo 'let objfiles = [' >> $@
	@set -e ; for d in $$(ocamlfind query -recursive -predicates native -format '%+a' ramen | uniq | grep -v -e compiler-libs -e ppx_tools -e /findlib) ; do \
	  echo $$d | cut -c $(OCAML_WHERE_LEN)- | \
	  sed -e 's,^\(.*\)$$,  N.path "\1" ;,' >> $@ ;\
	done ;
	@echo ']' >> $@
# Equivalent to -threads, must come right after unix.cmxa:
	@sed -i -e '/ocaml\/unix.cmxa/a \ \ N.path "ocaml/threads/threads.cmxa" ;' $@

src/RamenDepLibs.ml: src/RamenDepLibs.ml.frominst
ifeq ($(shell uname),Darwin)
	@sed -e '/inotify/d' $< > $@
else
	@cp $< $@
endif

# At the contrary, this one has to be generated at every build:
src/RamenCompilConfig.ml: Makefile
	@echo '(* Generated by Makefile - edition is futile *)' > $@
	@echo 'module N = RamenName' >> $@
	@echo 'let default_bundle_dir = N.path "$(lib_dir)/$(BUNDLE_DIR)/"' >> $@
	@echo 'let ocaml_version = "@OCAMLVERSION@"' >> $@
	@echo 'let build_path = "$(PATH)"' >> $@
	@echo 'let ocamlfind = N.path "@OCAMLFIND@"' >> $@
	@echo 'let ocamlpath = "$(OCAMLPATH)"' >> $@
	@echo 'let ocamllib = N.path "@OCAMLLIB@"' >> $@
	@echo 'let cpp_compiler = "@CXX@"' >> $@
	@echo 'let ocamlfind_destdir = N.path "$(OCAMLFIND_DESTDIR)"' >> $@

# Tests

TESTABLE_SOURCES = \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenExpr.ml \
	src/RamenGraphiteSink.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenTypingHelpers.ml \
	src/RamenProgram.ml \
	src/HeavyHitters.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenBloomFilter.ml \
	src/Globs.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSortBuf.ml \
	src/RamenGraphite.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenSerialization.ml \
	src/RamenSmtParser.ml \
	src/RamenUnits.ml \
	src/RamenTypeConverters.ml \
	src/RamenProcesses.ml\
	src/RamenSampling.ml \
	src/CodeGenLib.ml \
	src/RamenExport.ml \
	src/RamenOutRef.ml \
	src/RamenOCamlCompiler.ml

# For the actual command line building all_tests.opt:
LINKED_FOR_TESTS = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/HeavyHitters.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypeConverters.ml \
	src/RamenTypes.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenNullable.ml \
	src/RamenCollectd.ml \
	src/RamenNetflow.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenLang.ml \
	src/RamenExpr.ml \
	src/RamenWatchdog.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenBinocle.ml \
	src/RamenNotification.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenOutRef.ml \
	src/RamenConf.ml \
	src/RamenTypingHelpers.ml \
	src/RamenProgram.ml \
	src/Globs.ml \
	src/RamenCompilConfig.ml \
	src/RamenDepLibs.ml \
	src/RamenOCamlCompiler.ml \
	src/RamenHeap.ml \
	src/RamenSortBuf.ml \
	src/CodeGen_OCaml.ml \
	src/RamenBitmask.ml \
	src/RamenSerialization.ml \
	src/HeavyHitters.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenTypingErrors.ml \
	src/RamenTyping.ml \
	src/RamenCompiler.ml \
	src/RamenMake.ml \
	src/RamenProcesses.ml \
	src/RamenPs.ml \
	src/RamenArchivist.ml \
	src/RamenExport.ml \
	src/RamenTimeseries.ml \
	src/RamenHttpHelpers.ml \
	src/RamenBloomFilter.ml \
	src/RamenGraphite.ml \
	src/TestHelpers.ml \
	src/RamenNullable.ml \
	src/RamenFileNotify.ml \
	src/CodeGenLib_IO.ml \
	src/RamenSampling.ml \
	src/CodeGenLib.ml

src/all_tests.ml: $(TESTABLE_SOURCES)
	@echo 'Generating unit tests into $@'
	@$(QTEST) --shuffle -o $@ extract $^

all_tests.opt: \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		$(LINKED_FOR_TESTS:.ml=.cmx) src/all_tests.ml
	@echo 'Building unit tests into $@'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) -package qcheck $(filter %.cmx, $^) $(filter %.a, $^) $(filter %.ml, $^) -o $@

ringbuf_test.opt: \
		src/RamenLog.cmx \
		src/RamenAtomic.cmx \
		src/RamenHelpers.cmx \
		src/RamenChannel.cmx \
		src/RamenParsing.cmx \
		src/RamenEthAddr.cmx \
		src/RamenIpv4.cmx \
		src/RamenIpv6.cmx \
		src/RamenIp.cmx \
		src/RamenTypeConverters.cmx \
		src/RamenTypes.cmx \
		src/RamenName.cmx \
		src/RamenConsts.cmx \
		src/RamenFiles.cmx \
		src/RamenAdvLock.cmx \
		src/RamenFieldMask.cmx \
		src/RamenOutRef.cmx \
		src/RamenUnits.cmx \
		src/RamenTuple.cmx \
		src/RamenVersions.cmx \
		src/RingBuf.cmx \
		src/RingBufLib.cmx \
		src/RamenOrc.cmx \
		src/ringbuf_test.cmx \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a
	@echo 'Building ringbuf tests into $@'
	@$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

check: unit-check cli-check func-check err-check arc-check orc-check

unit-check: all_tests.opt ringbuf_test.opt
	@echo 'Running unit tests...'
	@TZ=CET OCAMLRUNPARAM=b ./all_tests.opt -bt
	@timeout 3 ./ringbuf_test.opt

cli-check:
	@echo 'Running CLI tests...'
	@mkdir -p tests/results/cli-check
	@cd tests && cucumber -f pretty -f junit -o results/cli-check/junit.xml

RAMEN_TESTS = $(wildcard tests/func/*.test)

RAMEN_TESTS_SOURCES = \
	$(RAMEN_TESTS:.test=.ramen) \
	$(wildcard tests/func/fixtures/*.ramen)

%.x: %.ramen $(BUNDLE_DIR)/ramen/codegen.a src/ramen src/codegen.cmxa
	@echo 'Compiling ramen program $@'
	@src/ramen compile --bundle=bundle -L . -L tests/func $< -o $@

%.success: %.test src/ramen
	@echo 'Running test $(basename $< .test)'
	@$(RM) $@
	@src/ramen test $< && touch $@

# One day we will have `ramen makedep`:
tests/func/lag.x: tests/func/fixtures/n123.x
tests/func/count_lines.x: tests/func/fixtures/n123.x
tests/func/params.x: tests/func/fixtures/earthquakes.x
tests/func/sort.x: tests/func/fixtures/earthquakes.x
tests/func/fit_multi.x: tests/func/fixtures/cars.x
tests/func/top_expr.x: tests/func/fixtures/cars.x
tests/func/season.x: tests/func/fixtures/earthquakes.x
tests/func/previous_and_null.x: tests/func/fixtures/n123.x
tests/func/fun_with_funcs.x: tests/func/fixtures/cars.x
tests/func/case.x: tests/func/fixtures/n123.x
tests/func/commit_before.x: tests/func/fixtures/n123.x tests/func/fixtures/cars.x
tests/func/basic_aggr.x: tests/func/fixtures/n123.x tests/func/fixtures/cars.x
tests/func/moveavg.x: tests/func/fixtures/n123.x
tests/func/tuples.x: tests/func/fixtures/n123.x
tests/func/groups.x: tests/func/fixtures/cars.x
tests/func/port_scan.x: tests/func/fixtures/port_scan.x
tests/func/ip.x: tests/func/fixtures/mixture.x
tests/func/histogram.x: tests/func/fixtures/cars.x
tests/func/last.x: tests/func/fixtures/earthquakes.x tests/func/fixtures/cars.x
tests/func/sample.x: tests/func/fixtures/n123.x
tests/func/merge.x: tests/func/fixtures/n123.x
tests/func/patterns.x: tests/func/fixtures/cars.x
tests/func/past.x: tests/func/fixtures/earthquakes.x
tests/func/lag.success: tests/func/lag.x tests/func/fixtures/n123.x
tests/func/count_lines.success: tests/func/count_lines.x tests/func/fixtures/n123.x
tests/func/params.success: tests/func/params.x tests/func/fixtures/earthquakes.x
tests/func/sort.success: tests/func/sort.x tests/func/fixtures/earthquakes.x
tests/func/fit_multi.success: tests/func/fit_multi.x tests/func/fixtures/cars.x
tests/func/top_expr.success: tests/func/top_expr.x tests/func/fixtures/cars.x
tests/func/season.success: tests/func/season.x tests/func/fixtures/earthquakes.x
tests/func/merge.success: tests/func/merge.x tests/func/fixtures/n123.x
tests/func/from.success: tests/func/from.x
tests/func/previous_and_null.success: tests/func/previous_and_null.x tests/func/fixtures/n123.x
tests/func/fun_with_funcs.success: tests/func/fun_with_funcs.x tests/func/fixtures/cars.x
tests/func/case.success: tests/func/case.x tests/func/fixtures/n123.x
tests/func/commit_before.success: tests/func/commit_before.x tests/func/fixtures/n123.x tests/func/fixtures/cars.x
tests/func/word_count.success: tests/func/word_count.x
tests/func/word_split.success: tests/func/word_split.x
tests/func/basic_aggr.success: tests/func/basic_aggr.x tests/func/fixtures/n123.x tests/func/fixtures/cars.x
tests/func/list_aggr.success: tests/func/list_aggr.x
tests/func/moveavg.success: tests/func/moveavg.x tests/func/fixtures/n123.x
tests/func/tuples.success: tests/func/tuples.x tests/func/fixtures/n123.x
tests/func/port_scan.success: tests/func/port_scan.x tests/func/fixtures/port_scan.x
tests/func/ip.success: tests/func/ip.x tests/func/fixtures/mixture.x
tests/func/min_max.success: tests/func/min_max.x
tests/func/nulls.success: tests/func/nulls.x
tests/func/constructed_types.success: tests/func/constructed_types.x
tests/func/histogram.success: tests/func/histogram.x tests/func/fixtures/cars.x
tests/func/strings.success: tests/func/strings.x
tests/func/in.success: tests/func/in.x
tests/func/time.success: tests/func/time.x
tests/func/last.success: tests/func/last.x tests/func/fixtures/earthquakes.x tests/func/fixtures/cars.x
tests/func/event_time.success: tests/func/event_time.x
tests/func/sample.success: tests/func/sample.x tests/func/fixtures/n123.x
tests/func/stress.success: tests/func/stress.x
tests/func/bits.success: tests/func/bits.x
tests/func/groups.success: tests/func/groups.x
tests/func/patterns.success: tests/func/patterns.x tests/func/fixtures/cars.x
tests/func/past.success: tests/func/past.x tests/func/fixtures/earthquakes.x
tests/func/casts.success: tests/func/casts.x
tests/func/changed.success: tests/func/changed.x

func-check: $(RAMEN_TESTS:.test=.success)

err-check: \
		src/ramen \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a \
		$(wildcard tests/errors/*.ramen) \
		$(wildcard tests/errors/*.err)
	@echo 'Running parsing/typing error tests'
	@for f in $(wildcard tests/errors/*.ramen); do \
	  t=$$(mktemp) ;\
	  src/ramen compile --quiet --bundle=bundle -L tests/errors $$f 2>&1 >/dev/null |\
	    sed 1d > $$t ;\
	  if ! diff -q $$f.err $$t ; then \
	    echo "\033[1;31mFAILURE\033[0m: $$f" ;\
	    exit 1 ;\
	  fi ;\
	  $(RM) $$t ;\
	done ;\
	echo "\033[1;32mSUCCESS\033[0m"

RAMEN_ARCHIVIST_TESTS = $(wildcard tests/archivist/*.allocs)

arc-check: src/ramen $(RAMEN_ARCHIVIST_TESTS)
	@echo 'Running storage allocation tests'
	@set -e; \
	 for f in $(RAMEN_ARCHIVIST_TESTS); do \
	  echo "  Testing $$(basename $$f .allocs)" ;\
	  d=$$(dirname $$f)/$$(basename $$f .allocs) ;\
	  src/ramen archivist --persist-dir $$d --no-stats --no-reconf --stdout ;\
	  if ! diff -q $$f $$d/archivist/v*/allocs ; then \
	    echo "\033[1;31mFAILURE\033[0m: $$f" ;\
	    exit 1 ;\
	  fi ;\
	done ;\
	echo "\033[1;32mSUCCESS\033[0m"

# Installation

install: $(INSTALLED)
	@ocamlfind install ramen $(INSTALLED_LIB) META
	@echo 'Installing binaries into $(bin_dir)'
	@install -d $(bin_dir)
	@install $(INSTALLED_BIN) $(bin_dir)/
	@for f in $(INSTALLED_BIN); do strip $(bin_dir)/$$(basename $$f); done

# We need ocamlfind to find ramen package before we can install the lib bundle.
# Therefore we simply build it as a separate, optional step (that's only
# required if you intend to use the embedded compiler).
install-bundle: bundle
	@echo 'Installing libraries bundle into $(DESTDIR)$(lib_dir)'
	@install -d $(DESTDIR)$(lib_dir)
	@cp -r $(BUNDLE_DIR) $(DESTDIR)$(lib_dir)/

install-examples:
	@echo 'Installing examples into $(DESTDIR)$(sample_dir)'
	@install -d $(DESTDIR)$(lib_dir)
	@cd examples/programs &&\
	 find . -type f -name '*.ramen' \
	   -exec sh -c 'mkdir -p $(DESTDIR)$(sample_dir)/$$(dirname {})' \; \
	   -exec sh -c 'cp {} $(DESTDIR)$(sample_dir)/$$(dirname {})' \;

install-systemd:
	@echo 'Installing systemd configuration into $(DESTDIR)$(systemd_dir)'
	@install -d $(DESTDIR)$(systemd_dir)
	@install -d $(DESTDIR)$(sysconf_dir)
	@cp systemd/*.target systemd/*.service $(DESTDIR)$(systemd_dir)
	@cp systemd/ramen $(DESTDIR)$(sysconf_dir)

uninstall:
	@ocamlfind remove ramen
	@echo 'Uninstalling binaries and libraries bundle'
	@$(RM) $(bin_dir)/ramen

uninstall-bundle:
	@echo 'Uninstalling libraries bundle'
	@$(RM) -r $(DESTDIR)$(lib_dir)/$(BUNDLE_DIR)

reinstall: uninstall install

# Debian package

deb: ramen.$(VERSION).deb

tarball: ramen.$(VERSION).tgz

ramen.$(VERSION).deb: \
		$(INSTALLED) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a \
		debian.control
	@echo 'Building debian package $@'
	@sudo rm -rf debtmp
	@install -d debtmp/usr/bin
	@install $(INSTALLED_BIN) debtmp/usr/bin
	@for f in $(INSTALLED_BIN); do strip debtmp/usr/bin/$$(basename $$f); done
	@$(MAKE) DESTDIR=$(PWD)/debtmp/ install-examples
	@$(MAKE) DESTDIR=$(PWD)/debtmp/ install-bundle
	@$(MAKE) DESTDIR=$(PWD)/debtmp/ install-systemd
	@mkdir -p debtmp/DEBIAN
	@cp debian.control debtmp/DEBIAN/control
	@chmod -R a+x debtmp/usr
	@sudo chown root: -R debtmp/usr
	@dpkg --build debtmp
	@mv debtmp.deb $@

ramen.$(VERSION).tgz: \
		$(INSTALLED_BIN) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a
	@echo 'Building tarball $@'
	@$(RM) -r tmp/ramen
	@install -d tmp/ramen
	@install $(INSTALLED_BIN) tmp/ramen/
	@install $(Z3) tmp/ramen/
	@for f in $(INSTALLED_BIN) z3; do strip tmp/ramen/$$(basename $$f); done
	@chmod -R a+x tmp/ramen/*
	@$(MAKE) DESTDIR=$(PWD)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-examples
	@$(MAKE) DESTDIR=$(PWD)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-bundle
	@$(MAKE) DESTDIR=$(PWD)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-systemd
	@tar c -C tmp ramen | gzip > $@

# Docker images

docker-latest: docker/Dockerfile docker/ramen.$(VERSION).deb
	@echo 'Building docker image for testing DEB version'
	@docker build -t rixed/ramen:latest --squash -f $< docker/

docker/ramen.$(VERSION).deb: ramen.$(VERSION).deb
	@echo 'Copying debian package into docker/'
	@cp $< $@

docker-build-builder: docker/Dockerfile-builder
	@for distrib in jessie stretch ; do \
	  echo 'Building docker image for building the DEB packages for $$distrib' ;\
	  echo 'FROM debian:'$$distrib > docker/Dockerfile-builder.$$distrib ;\
	  cat docker/Dockerfile-builder >> docker/Dockerfile-builder.$$distrib ;\
	  docker build -t rixed/ramen-builder:$$distrib \
	               -f docker/Dockerfile-builder.$$distrib docker/ ;\
	  $(RM) docker/Dockerfile-builder.$$distrib ;\
	done

docker/z3: $(Z3)
	@echo 'Copying z3 from system into docker/'
	@cp $< $@

docker-build-image: docker-latest docker/z3
	@echo 'Tagging latest docker image to v$(VERSION)'
	@docker tag rixed/ramen:latest rixed/ramen:v$(VERSION)

docker-circleci: docker/Dockerfile-circleci
	@echo 'Building docker image for CircleCi'
	@docker build -t rixed/ramen-circleci -f $< docker/

docker-push:
	@echo 'Uploading docker images'
	@docker push rixed/ramen:latest
	@docker push rixed/ramen:v$(VERSION)
	@docker push rixed/ramen-builder:jessie
	@docker push rixed/ramen-builder:stretch
	@docker push rixed/ramen-circleci

# Cleaning

clean-temp:
	@echo 'Cleaning ramen compiler temp files'
	@for d in tests examples ; do\
	   find $$d -\( -name '*.cc' -o -name '*.ml' -o -name '*.cmx' \
	                -o -name '*.o' -o -name '*.annot' -o -name '*.cmt' \
	                -o -name '*.cmti' -o -name '*.x' -o -name '*.s' \
	                -o -name '*.cmi' -o -name '*.smt2' -\) \
	            -delete ;\
	 done

clean-dist: clean clean-temp
	@echo 'Cleaning all build files'
	@$(RM) doc/tutorial.html doc/manual.html doc/roadmap.html
	@find tests -name '*.success' -delete
	@$(RM) -r $(BUNDLE_DIR)
	@sudo rm -rf debtmp
	@$(RM) -r tmp
	@$(RM) ramen.*.deb ramen.*.tgz
	@$(RM) $(PAGES)
	@$(RM) META

clean:
	@echo 'Cleaning result'
	@$(RM) src/*.s src/*.annot src/*.cmt src/*.cmti src/*.o src/*.mlppp
	@$(RM) *.opt src/all_tests.* perf.data* gmon.out
	@$(RM) src/ringbuf/*.o src/orc/*.o
	@$(RM) src/*.cmx src/*.cmxa src/*.cmxs src/*.cmi
	@$(RM) src/orc/*.cmx src/orc/*.annot src/orc/*.cmt src/orc/*.cmxs src/orc/*.cmi
	@$(RM) src/oUnit-anon.cache src/qtest.targets.log
	@$(RM) .depend src/*.opt src/*.byte
	@$(RM) src/RamenFileNotify.ml RamenCompilConfig.ml
	@$(RM) src/ramen src/codegen.cmxa src/libringbuf.a src/liborchelp.a
	@$(RM) src/libcollectd.a src/libnetflow.a src/codegen.a src/liborchelp.a
