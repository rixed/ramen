# Configuration

VERSION = @PACKAGE_VERSION@
BUNDLE_DIR = bundle

DUPS_IN  = $(shell ocamlfind query compiler-libs)
OCAMLC   = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamlc
OCAMLOPT = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamlopt
OCAMLDEP = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamldep
QTEST    = qtest
LINUXDEPLOY = linuxdeploy-x86_64.AppImage

WARNS    = -w -40-58+27
OCAMLOPTFLAGS = @OCAMLOPTFLAGS@ -thread -I src -I $(BUNDLE_DIR)/lib $(WARNS) -annot -bin-annot
OCAMLCFLAGS = @OCAMLCFLAGS@ -thread -I src -I $(BUNDLE_DIR)/lib $(WARNS) -annot

ifneq (@QMAKE@,)
ifneq (@CONVERT@,)
BUILD_RMADMIN = 1
else
BUILD_RMADMIN =
endif
else
BUILD_RMADMIN =
endif

CFLAGS   += -std=gnu11   -Wall -W -Wno-parentheses -fPIC
CXXFLAGS += -std=gnu++17 -Wall -W -Wno-parentheses -fPIC
CPPFLAGS += -D_GNU_SOURCE \
            -I '@OCAMLLIB@' \
            -I '$(BUNDLE_DIR)/include' \
            -DHAVE_INT128 -I '$(shell ocamlfind query stdint)'

ifdef NDEBUG
OCAMLOPTFLAGS += -noassert -O2
OCAMLCFLAGS += -noassert -O2
CPPFLAGS += -DNDEBUG
CFLAGS += -O3
CXXFLAGS += -DNDEBUG -O3
QMAKE_EXTRA = "CONFIG+=release"
STRIP_BIN = 1
else
OCAMLOPTFLAGS += -g
OCAMLCFLAGS += -g
CPPFLAGS += -g
CFLAGS += -O0
CXXFLAGS += -O0 -g
QMAKE_EXTRA = "CONFIG+=debug"
endif

# parsercombinator is used by string to IP conversion :(
META_REQUIRES = \
	findlib batteries stdint parsercombinator threads dessser \
	pfds binocle lacaml lmdb ppp ppp.unix syslog zmq sodium kafka
# The above are the dependencies required when ramen is running.
# To build ramen you will also need:
#   unix num js_of_ocaml js_of_ocaml-ppx cmdliner sqlite3
#   compiler-libs compiler-libs.common
#   compiler-libs.bytecomp compiler-libs.optcomp

PACKAGES = \
	ppp ppp.ppx ppp.unix batteries cmdliner stdint parsercombinator \
	pfds syslog num binocle unix lacaml lmdb threads dessser \
	compiler-libs compiler-libs.common compiler-libs.bytecomp \
	compiler-libs.optcomp net_codecs sqlite3 zmq sodium kafka

ifeq ($(shell uname),Darwin)
FILE_NOTIFIER = src/RamenFileNotify_Poller.ml
else
FILE_NOTIFIER = src/RamenFileNotify_Inotify.ml
META_REQUIRES += inotify
PACKAGES += inotify
endif

# `make` should compile and install everything, yet to build the deb or
# tarball RmAdmin is not needed:
PACKAGED_BIN = src/ramen
INSTALLED_BIN = $(PACKAGED_BIN)
ifeq ($(BUILD_RMADMIN),1)
INSTALLED_BIN += rmadmin/RmAdmin
endif

INSTALLED_LIB = \
	src/codegen.cmxa src/codegen.a \
	$(filter %.cmi, $(CODEGENLIB_SOURCES:.ml=.cmi)) \
	$(filter %.cmx, $(CODEGENLIB_SOURCES:.ml=.cmx)) \
	src/libringbuf.a src/libcollectd.a src/libnetflow.a \
	src/liborchelp.a
INSTALLED_RAMEN_PROGRAMS = \
	src/local.x src/global.x
INSTALLED = $(INSTALLED_BIN) $(INSTALLED_LIB) $(INSTALLED_RAMEN_PROGRAMS) META

prefix = @prefix@
exec_prefix = @exec_prefix@
bin_dir ?= @bindir@
# Where the deb (or other non-opam) version of ramen will get the libraries
# bundle from. This is important that the ramen package is compiled with the
# correct path as we use opam installed libs to build the non-opam bundle,
# or RamenCompilConfig will be incompatible).
lib_dir ?= @libexecdir@

# Where examples are installed
sample_dir ?= @sharedstatedir@

# Where to install systemd configuration
systemd_dir ?= /lib/systemd/system
sysconf_dir ?= /etc/default

all: $(INSTALLED) bundle

# Generic rules

.SUFFIXES: .ml .mli .cmi .cmx .cmo .cmxs .cmt .top .html .adoc .ramen .x .test .success
.PHONY: clean clean-temp all dep bundle doc deb tarball bundle \
        check func-check unit-check cli-check err-check arc-check orc-check \
        install install-bundle install-examples install-systemd uninstall reinstall \
        docker docker-dev docker-push appimage coverity

%.cmi: %.cmx
	@true

src/RamenName.cmi: src/RamenName.mli
	@echo 'Compiling $@ (interface)'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c $<

src/RamenChannel.cmi: src/RamenChannel.mli
	@echo 'Compiling $@ (interface)'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c $<

%.cmx %.cmt: %.ml
	@echo 'Compiling $@ (native)'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c $<

%.cmo %.cmt: %.ml
	@echo 'Compiling $@ (bytecode)'
	$(OCAMLC) $(OCAMLCFLAGS) -package "$(PACKAGES)" -c $<

%.html: %.adoc
	@echo 'Building documentation $@'
	asciidoc -a data-uri -a icons -a toc -a max-width=55em --theme volnitsky -o $@ $<

RAMEN_SOURCES = \
	src/RamenVersions.ml \
	src/RamenAtomic.ml \
	src/RamenNullable.ml \
	src/RamenLog.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenHelpers.ml \
	src/RamenBitmask.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenTimeRange.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenParams.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenLang.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenWorkerStats.ml \
	src/RamenWorkerStatsSerialization.ml \
	src/RamenNotification.ml \
	src/RamenNotificationSerialization.ml \
	src/RamenExpr.ml \
	src/Globs.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenCompilConfig.ml \
	src/RamenRetention.ml \
	src/RamenSerialization.ml \
	src/RamenWatchdog.ml \
	src/HeavyHitters.ml \
	src/RamenDepLibs.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/CodeGen_Dessser.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenConf.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTypingErrors.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSyncHelpers.ml \
	src/RamenPaths.ml \
	src/RamenSyncUsers.ml \
	src/RamenOutRef.ml \
	src/RamenServices.ml \
	src/RamenFileNotify.ml \
	src/RamenProcesses.ml \
	src/RamenCompiler.ml \
	src/RamenReplay.ml \
	src/RamenPs.ml \
	src/RamenArchivist.ml \
	src/RamenExport.ml \
	src/RamenTimeseries.ml \
	src/RamenHttpHelpers.ml \
	src/RamenGc.ml \
	src/RamenRun.ml \
	src/RamenGraphite.ml \
	src/RamenApi.ml \
	src/RamenMake.ml \
	src/RamenSupervisor.ml \
	src/RamenHeap.ml \
	src/RamenSzHeap.ml \
	src/SqliteHelpers.ml \
	src/RamenStringExpansion.ml \
	src/RamenAlerter.ml \
	src/TermTable.ml \
	src/RamenHttpd.ml \
	src/RamenCopy.ml \
	src/RamenCopySrv.ml \
	src/RamenSyncServer.ml \
	src/RamenSourceExamples.ml \
	src/RamenSyncZMQServer.ml \
	src/RamenChoreographer.ml \
	src/RamenReplayService.ml \
	src/RamenPrecompserver.ml \
	src/RamenExecompserver.ml \
	src/RamenCliCmd.ml \
	src/RingBufCmd.ml \
	src/RamenCompletion.ml \
	src/RamenTests.ml \
	src/ramen.ml

CODEGENLIB_SOURCES = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenNullable.ml \
	src/RamenAtomic.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenHelpers.ml \
	src/Globs.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenWatchdog.ml \
	src/RamenAdvLock.ml \
	src/RamenFieldMask.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RingBuf.ml \
	src/RamenTypeConverters.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenWorkerStats.ml \
	src/RamenWorkerStatsSerialization.ml \
	src/RamenNotification.ml \
	src/RamenNotificationSerialization.ml \
	src/RamenBloomFilter.ml \
	src/RamenSampling.ml \
	src/RamenFileNotify.ml \
	src/RamenParams.ml \
	src/RamenLang.ml \
	src/RamenExpr.ml \
	src/RamenProtocols.ml \
	src/RamenTuple.ml \
	src/RamenOperation.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenTimeRange.ml \
	src/RamenRetention.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenCompilConfig.ml \
	src/RamenConf.ml \
	src/RamenHeap.ml \
	src/RamenSzHeap.ml \
	src/RamenSortBuf.ml \
	src/HeavyHitters.ml \
	src/RamenOutRef.ml \
	src/CodeGenLib.ml \
	src/CodeGenLib_Config.ml \
	src/CodeGenLib_Factors.ml \
	src/CodeGenLib_Stats.ml \
	src/CodeGenLib_IO.ml \
	src/CodeGenLib_State.ml \
	src/CodeGenLib_Casing.ml \
	src/CodeGenLib_Publish.ml \
	src/CodeGenLib_Globals.ml \
	src/RamenCopy.ml \
	src/RamenCopyClt.ml \
	src/CodeGenLib_Skeletons.ml

RMADMIN_SOURCES = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenTimeRange.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenRetention.ml \
	src/Globs.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenParams.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenLang.ml \
	src/RamenExpr.ml \
	src/RamenCollectd.ml \
	src/RamenWorkerStats.ml \
	src/RamenTypeConverters.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenNotification.ml \
	src/RamenNullable.ml \
	src/RamenGraphiteSink.ml \
	src/RamenNetflow.ml \
	src/RamenProtocols.ml \
	src/RamenEventTime.ml \
	src/RamenTuple.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	rmadmin/GuiHelper.ml

LIBRINGBUF_SOURCES = \
	src/config.h \
	src/ringbuf/archive.h \
	src/ringbuf/archive.c \
	src/ringbuf/miscmacs.h \
	src/ringbuf/ringbuf.h \
	src/ringbuf/ringbuf.c \
	src/ringbuf/wrappers.c

LIBCOLLECTD_SOURCES = \
	src/collectd/collectd.h \
	src/collectd/collectd.c \
	src/collectd/wrappers.c

LIBNETFLOW_SOURCES = \
	src/netflow/v5.c

LIBORC_SOURCES = \
	src/orc/wrappers.cc

ORCWRITER_SOURCES = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenNullable.ml \
	src/RamenAtomic.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenHelpers.ml \
	src/RamenTimeRange.ml \
	src/Globs.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenParams.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenLang.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenWorkerStats.ml \
	src/RamenWorkerStatsSerialization.ml \
	src/RamenNotification.ml \
	src/RamenNotificationSerialization.ml \
	src/RamenExpr.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenCompilConfig.ml \
	src/RamenRetention.ml \
	src/RamenSerialization.ml \
	src/RamenDepLibs.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/CodeGen_Dessser.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenConf.ml \
	src/RamenTypingErrors.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_OCaml.ml \
	src/RamenOutRef.ml \
	src/RamenPaths.ml \
	src/RamenProcesses.ml \
	src/RamenCompiler.ml \
	src/orc/orc_writer.ml

TESTONLY_SOURCES = \
	src/TestHelpers.ml \
	src/ringbuf_test.ml \
	src/ringbuf/test.c

SOURCES = $(sort \
	$(RAMEN_SOURCES) \
	$(CODEGENLIB_SOURCES) \
	$(RMADMIN_SOURCES) \
	$(LIBRINGBUF_SOURCES) \
	$(LIBRINGBUF_OCAML_SOURCES) \
	$(LIBCOLLECTD_SOURCES) \
	$(LIBNETFLOW_SOURCES) \
	$(ORCWRITER_SOURCES) \
	$(LIBORC_SOURCES) \
	$(TESTONLY_SOURCES) \
)


# Dependencies

dep:
	$(RM) .depend
	$(MAKE) .depend

.depend: $(SOURCES)
	$(OCAMLDEP) -I src -package "$(PACKAGES)" $(filter %.ml, $(SOURCES)) $(filter %.mli, $(SOURCES)) > $@
	@for f in $(filter %.c, $(SOURCES)); do \
	  $(CC) $(CFLAGS) $(CPPFLAGS) -MM -MT "$$(dirname $$f)/$$(basename $$f .c).o" $$f >> $@; \
	done

include .depend


# Documentation

doc: docs/tutorial.html docs/manual.html docs/roadmap.html

docs/tutorial.html: docs/tutorial_group_by.svg docs/sample_chart1.svg


# Compile Ramen

src/RamenFileNotify.ml: $(FILE_NOTIFIER)
	@echo 'Using implementation $(FILE_NOTIFIER) for new file notifications'
	@ln -sf $(notdir $<) $@
	@touch $@

src/libringbuf.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBRINGBUF_SOURCES)))
	@echo 'Building ringbuf library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

src/libcollectd.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBCOLLECTD_SOURCES)))
	@echo 'Building collectd library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

src/libnetflow.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBNETFLOW_SOURCES)))
	@echo 'Building netflow library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

src/liborchelp.a: $(patsubst %.cc,%.o,$(filter %.cc, $(LIBORC_SOURCES)))
	@echo 'Building orc helper library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs $@ $^ >/dev/null

submodules/orc/NOTICE: .gitmodules
	@echo "Getting submodules"
	@git submodule init
	@git submodule update
	@touch $@

src/global.x: src/local.x

# We need the ORC include files to be installed for that one:
src/orc/wrappers.o: $(BUNDLE_DIR)/lib/liborc.a

$(BUNDLE_DIR)/lib/liborc.a: $(BUNDLE_DIR)/date submodules/orc/NOTICE
	@echo 'Building liborc'
	@mkdir -p submodules/orc/build
	@cd submodules/orc/build &&\
	 CPPFLAGS='$(CFLAGS) $(CPPFLAGS)' cmake .. -DBUILD_JAVA=OFF -DCMAKE_BUILD_TYPE=DEBUG -DCMAKE_INSTALL_PREFIX:PATH=$(PWD)/$(BUNDLE_DIR) &&\
	 make install
	@touch $@

$(BUNDLE_DIR)/include/caml:
	@echo 'Copying OCaml headers'
	@cp -r $(shell ocamlfind ocamlc -where)/caml $(BUNDLE_DIR)/include

$(BUNDLE_DIR)/include/dessser:
	@echo 'Copying Dessser headers'
	@install -d $(BUNDLE_DIR)/include/dessser
	@cp $(wildcard $(shell ocamlfind query dessser)/*.h) $(BUNDLE_DIR)/include/dessser/

# We have to force -cclib -lstdint_stubs right after -cclib wrap_ringbuf.o
# otherwise -package stdint would put it before and gcc would not include the
# symbols we need as we are the only users.
MOREFLAGS = \
	-package "$(PACKAGES)" \
	-cclib -lstdint_stubs \
	-cclib -lorchelp \
	-cclib -lringbuf \
	-cclib -lcollectd \
	-cclib -lnetflow \
	-cclib -lorc \
	-cclib -lhdfspp_static \
	-cclib -llz4 \
	-cclib -lprotobuf \
	-cclib -lzstd \
	-cclib -lsnappy \
	-cclib -lz \
	-cclib -lsasl2 \
	-cclib -lcrypto \
	-cclib -lstdc++

src/orc/orc_writer: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(ORCWRITER_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter %.ml, $(ORCWRITER_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a
	@echo 'Linking $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/ramen: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(RAMEN_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter %.ml, $(RAMEN_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a
	@echo 'Linking $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/ramen.byte: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(RAMEN_SOURCES))) \
		$(patsubst %.ml,%.cmo,$(filter %.ml, $(RAMEN_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a
	@echo 'Linking $@'
	$(OCAMLC) $(OCAMLCFLAGS) -linkpkg $(MOREFLAGS) -cclib -lsodium -cclib -lsodium_stubs $(filter %.cmo, $^) -o $@

src/codegen.cmxa: \
		$(filter %.cmx,$(CODEGENLIB_SOURCES:.ml=.cmx)) \
		$(filter %.cmi,$(CODEGENLIB_SOURCES:.ml=.cmi)) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a
	@echo 'Linking runtime library $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -a $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/codegen.cma: \
		$(filter %.cmo,$(CODEGENLIB_SOURCES:.ml=.cmo)) \
		$(filter %.cmi,$(CODEGENLIB_SOURCES:.ml=.cmi)) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a
	@echo 'Linking runtime library $@'
	$(OCAMLC) $(OCAMLCFLAGS) -a $(MOREFLAGS) $(filter %.cmo, $^) -o $@

src/codegen.a: src/codegen.cmxa


# RmAdmin

RMADMIN_FLAGS = \
	-package batteries,stdint,syslog,cmdliner,zmq,sodium \
	-package ppp,ppp.ppx,ppp.unix,binocle,parsercombinator

rmadmin/GuiHelper.o: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(RMADMIN_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter-out rmadmin/GuiHelper.ml,$(filter %.ml, $(RMADMIN_SOURCES)))) \
		rmadmin/GuiHelper.ml
	@echo 'Generating OCaml GUI helper $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(RMADMIN_FLAGS) -package pfds $(filter %.cmx, $^) $(filter %.ml, $^) -output-obj -o rmadmin/GuiHelper_tmp.o
	mv rmadmin/GuiHelper_tmp.o $@
	@# Also helps `qmake Makefile` to notice the dependency:
	touch rmadmin/main.cpp

rmadmin/qcustomplot.cpp:
	@echo 'Downloading qcustomplot'
	wget https://www.qcustomplot.com/release/2.0.1/QCustomPlot-source.tar.gz -O - | \
	  tar xz -C rmadmin --overwrite --strip-components=1 \
	    qcustomplot-source/qcustomplot.h qcustomplot-source/qcustomplot.cpp

rmadmin/RmAdmin: \
		rmadmin/GuiHelper.o \
		rmadmin/rmadmin.ico \
		rmadmin/rmadmin.pro \
		rmadmin/qcustomplot.cpp \
		$(wildcard rmadmin/*.cpp) \
		$(wildcard rmadmin/*.h)
	@echo 'Generating RMAdmin $@'
	cd rmadmin && @QMAKE@ $(QMAKE_EXTRA)
	$(MAKE) -C rmadmin
	@if ! test -e $@ && test -e rmadmin/RmAdmin.app ; then \
	  echo '#!/bin/sh' > $@ ;\
	  echo 'exec ./rmadmin/RmAdmin.app/Contents/MacOS/RmAdmin' >> $@ ;\
	  chmod a+x $@ ;\
	fi

# This ico file is used for Windows app icon and internally by RmAdmin (in the about window):
rmadmin/rmadmin.ico: site/icon.png
	@echo 'Generating $@'
	@CONVERT@ $< $@

rmadmin/rmadmin.icns: site/icon.png
	@echo 'Generating $@'
	$(RM) -r icon.iconset
	mkdir icon.iconset
	@CONVERT@ $< -resize 16x16 icon.iconset/icon_16x16.png
	@CONVERT@ $< -resize 32x32 icon.iconset/icon_16x16@2x.png
	@CONVERT@ $< -resize 32x32 icon.iconset/icon_32x32.png
	@CONVERT@ $< -resize 64x64 icon.iconset/icon_32x32@2x.png
	@CONVERT@ $< -resize 128x128 icon.iconset/icon_128x128@.png
	@CONVERT@ $< -resize 256x256 icon.iconset/icon_128x128@2x.png
	@CONVERT@ $< -resize 256x256 icon.iconset/icon_256x256.png
	@CONVERT@ $< -resize 512x512 icon.iconset/icon_256x256@2x.png
	@CONVERT@ $< -resize 512x512 icon.iconset/icon_512x512.png
	@CONVERT@ $< -resize 1024x1024 icon.iconset/icon_512x512@2x.png
	iconutil --convert icns --output $@ icon.iconset

rmadmin/RmAdmin.dmg: rmadmin/rmadmin.icns rmadmin/RmAdmin rmadmin/rmadmin.ico
	@echo 'Generating MacOS disk image $@'
	@cd rmadmin &&\
	 mkdir -p RmAdmin.app/Contents/Frameworks &&\
	 cp @OCAMLLIB@/libasmrun_shared.so RmAdmin.app/Contents/Frameworks &&\
	 install_name_tool -change libasmrun_shared.so @executable_path/../Frameworks/libasmrun_shared.so RmAdmin.app/Contents/MacOS/RmAdmin &&\
	 $(RM) RmAdmin.dmg &&\
	 macdeployqt RmAdmin.app -libpath=/usr/local/lib -dmg

# Better not relying on linuxdeploy for anything but gathering the libs
rmadmin/AppDir/usr/share/applications/RmAdmin.desktop: rmadmin/RmAdmin.desktop
	mkdir -p $(dir $@)
	cp -f $< $@

rmadmin/AppDir/usr/bin/RmAdmin: rmadmin/RmAdmin
	mkdir -p $(dir $@)
	cp -f $< $@

rmadmin/AppDir/usr/share/icons/hicolor/128x128/apps/RmAdmin.png: site/icon.png
	mkdir -p $(dir $@)
	cp -f $< $@

appimage: rmadmin/RmAdmin.$(VERSION).AppImage

rmadmin/RmAdmin.$(VERSION).AppImage: \
		rmadmin/AppDir/usr/share/applications/RmAdmin.desktop \
		rmadmin/AppDir/usr/bin/RmAdmin \
		rmadmin/AppDir/usr/share/icons/hicolor/128x128/apps/RmAdmin.png
	@echo 'Generating Linux AppImage into $@'
	LD_LIBRARY_PATH=@OCAMLLIB@ OUTPUT=$@ $(LINUXDEPLOY) --appdir=rmadmin/AppDir --plugin qt --output appimage

coverity:
	@echo 'Building and uploading coverity analysis'
	@test `whoami` = rixed
	@test -r .coverity_token
	@$(MAKE) -C rmadmin clean
	@cd rmadmin && \
	 cov-build --dir cov-int make && \
	 tar czvf ramen.tgz cov-int
	@curl \
	   --form token=`cat .coverity_token` \
	   --form email=rixed@free.fr \
	   --form file=rmadmin/ramen.tgz \
	   --form version="$(VERSION)" \
	   --form description="$(shell git rev-parse --short HEAD)" \
	   https://scan.coverity.com/builds?project=rixed%2Framen


# Bundle directory

# embedded compiler version: build a bundle of all libraries
OCAML_WHERE = $(shell dirname $(shell ocamlfind ocamlc -where))
# cut -c X- means to takes all from X, 1st char being 1, thus the leading _:
OCAML_WHERE_LEN = $(shell printf '_%s/' $(OCAML_WHERE) | wc -m | xargs echo)

META: Makefile
	@echo 'Building findlib configuration (META) for Ramen'
	@echo 'description = "Event processor tailored for human-scale monitoring"' > $@
	@echo 'version = "$(VERSION)"' >> $@
	@echo 'archive(native) = "codegen.cmxa"' >> $@
	@echo 'requires = "$(META_REQUIRES)"' >> $@

bundle: \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a \
		$(BUNDLE_DIR)/ramen/programs/global.x \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_DIR)/include/dessser

$(BUNDLE_DIR)/date:
	@echo '!!! REBUILDING $(BUNDLE_DIR) !!!'
	$(RM) -r '$(BUNDLE_DIR)'
	mkdir -p '$(BUNDLE_DIR)'
	touch $@

$(BUNDLE_DIR)/ramen/codegen.a: $(BUNDLE_DIR)/date $(INSTALLED_LIB)
	@echo 'Bundling libs together into $(BUNDLE_DIR)'
	$(RM) -r '$(BUNDLE_DIR).tmp'
	mkdir '$(BUNDLE_DIR).tmp'
	@set -e ;\
	 deps=$$( \
	   for p in $(META_REQUIRES) ; do \
	     ocamlfind query -recursive -predicates native,mt -format '%d' $$p ;\
	   done | sort -u | grep -v /findlib) ;\
	 for d in $$deps ; do cp -r "$$d" '$(BUNDLE_DIR).tmp/' ; done
	mkdir $(BUNDLE_DIR).tmp/ramen
	cp $(INSTALLED_LIB) $(BUNDLE_DIR).tmp/ramen
	find '$(BUNDLE_DIR).tmp' -type f -not '(' \
	    -name '*.cmx*' -o -name '*.cmi' -o -name '*.a' -o \
	    -name '*.so' -o -name '*.o' -o -name META \
	  ')' -delete
	find '$(BUNDLE_DIR).tmp' -empty -delete
	@# Delete some of the biggest unused files:
	$(RM) $(BUNDLE_DIR).tmp/batteries/batteriesExceptionless.cm*
	$(RM) -r $(BUNDLE_DIR).tmp/ocaml/compiler-libs
	$(RM) -r $(BUNDLE_DIR).tmp/ocaml/camlp4
	$(RM) -r $(BUNDLE_DIR).tmp/ocaml/ocamldoc
	$(RM) -r $(BUNDLE_DIR).tmp/ocaml/thread
	$(RM) -r $(BUNDLE_DIR).tmp/ocaml/ocplib*
	$(RM) $(BUNDLE_DIR).tmp/ocaml/camlinternalFormat.*
	$(RM) $(BUNDLE_DIR).tmp/ocaml/*spacetime*
	@# Delete everything that's not from liborc:
	mkdir -p '$(BUNDLE_DIR)'
	find '$(BUNDLE_DIR)' -maxdepth 1 -mindepth 1 -type d -not '(' \
	    -name lib -o -name include \
		')' -exec rm -rf '{}' \;
	mv $(BUNDLE_DIR).tmp/* $(BUNDLE_DIR)/
	$(RM) -r $(BUNDLE_DIR).tmp
	touch $@

$(BUNDLE_DIR)/ramen/programs/global.x: $(BUNDLE_DIR)/ramen/codegen.a $(INSTALLED_RAMEN_PROGRAMS)
	@echo 'Installing precompiled ramen programs'
	install -d $(BUNDLE_DIR)/ramen/programs
	install $(INSTALLED_RAMEN_PROGRAMS) $(BUNDLE_DIR)/ramen/programs/

# Bootstrapping this is a bit special as ocamlfind needs to know the ramen
# package first. Therefore this file is included with the source package for
# simplicity.
src/RamenDepLibs.ml.frominst:
	@echo '(* Generated by Makefile - edition is futile *)' > $@
	@echo 'module N = RamenName' >> $@
	@echo 'let incdirs = [' >> $@
	set -e ; for d in $$(ocamlfind query -recursive -predicates native,mt -format '%d' ramen | sort -u | grep -v -e compiler-libs -e ppx_tools -e /findlib) ; do \
	  echo $$d | cut -c $(OCAML_WHERE_LEN)- | \
	  sed -e 's,^\(.*\)$$,  N.path "\1" ;,' >> $@ ;\
	done ;
# Equivalent to -threads:
	@echo '  N.path "ocaml/threads" ;' >> $@
	@echo ']' >> $@
	@echo 'let objfiles = [' >> $@
	set -e ; for d in $$(ocamlfind query -recursive -predicates native,mt -format '%+a' ramen | uniq | grep -v -e compiler-libs -e ppx_tools -e /findlib) ; do \
	  echo $$d | cut -c $(OCAML_WHERE_LEN)- | \
	  sed -e 's,^\(.*\)$$,  N.path "\1" ;,' >> $@ ;\
	done ;
	@echo ']' >> $@
# Equivalent to -threads, must come right after unix.cmxa:
	sed -i -e '/ocaml\/unix.cmxa/a \ \ N.path "ocaml/threads/threads.cmxa" ;' $@

src/RamenDepLibs.ml: src/RamenDepLibs.ml.frominst Makefile
ifeq ($(shell uname),Darwin)
	sed -e '/inotify/d' $< > $@
else
	cp $< $@
endif

src/RamenCompilConfig.ml: Makefile
	@echo '(* Generated by Makefile - edition is futile *)' > $@
	@echo 'module N = RamenName' >> $@
	@echo 'let default_bundle_dir = N.path "$(abspath $(lib_dir))/$(BUNDLE_DIR)/"' >> $@
	@echo 'let ocaml_version = "@OCAMLVERSION@"' >> $@
	@echo 'let build_path = "$(PATH)"' >> $@
	@echo 'let ocamlfind = N.path "@OCAMLFIND@"' >> $@
	@echo 'let ocamlpath = "$(OCAMLPATH)"' >> $@
	@echo 'let cpp_compiler = "@CXX@"' >> $@
	@echo 'let z3_path = "@Z3@"' >> $@
	@echo 'let build_date = "$(shell date -R)"' >> $@
	@echo 'let build_host = "$(shell hostname)"' >> $@

src/RamenSourceExamples.ml: \
		Makefile \
		examples/programs/monitoring/network/security.ramen \
		examples/programs/monitoring/network/hosts.ramen \
		examples/programs/monitoring/network/traffic.ramen \
		examples/programs/monitoring/generated/logs.ramen \
		examples/programs/monitoring/generated/aggregated.ramen \
		examples/programs/monitoring/generated/alerts/error_rate.alert
	@echo 'Generating $@'
	@echo '(* Generated by Makefile - edition is futile *)' > $@
	@echo >> $@
	@echo 'module Monitoring = struct' >> $@
	@echo '  module Network = struct' >> $@
	@echo '    let security = {|' >> $@
	cat examples/programs/monitoring/network/security.ramen >> $@
	@echo '|}' >> $@
	@echo >> $@
	@echo '    let hosts = {|' >> $@
	cat examples/programs/monitoring/network/hosts.ramen >> $@
	@echo '|}' >> $@
	@echo >> $@
	@echo '    let traffic = {|' >> $@
	cat examples/programs/monitoring/network/traffic.ramen >> $@
	@echo '|}' >> $@
	@echo '  end' >> $@
	@echo >> $@
	@echo '  module Generated = struct' >> $@
	@echo '    let logs = {|' >> $@
	cat examples/programs/monitoring/generated/logs.ramen >> $@
	@echo '|}' >> $@
	@echo >> $@
	@echo '    let aggregated = {|' >> $@
	cat examples/programs/monitoring/generated/aggregated.ramen >> $@
	@echo '|}' >> $@
	@echo >> $@
	@echo '    let error_rate = {|' >> $@
	@cat examples/programs/monitoring/generated/alerts/error_rate.alert >> $@
	@echo '|}' >> $@
	@echo '  end' >> $@
	@echo 'end' >> $@
	sed -i -e ':x /{|$$/{N;s/\n//g; bx}' $@

# Tests

TESTABLE_SOURCES = \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenName.ml \
	src/RamenTimeRange.ml \
	src/RamenExpr.ml \
	src/RamenGraphiteSink.ml \
	src/Globs.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenTypingHelpers.ml \
	src/RamenProgram.ml \
	src/HeavyHitters.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenBloomFilter.ml \
	src/CodeGen_Dessser.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSortBuf.ml \
	src/RamenGraphite.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenSerialization.ml \
	src/RamenSmtParser.ml \
	src/RamenUnits.ml \
	src/RamenTypeConverters.ml \
	src/RamenServices.ml \
	src/RamenProcesses.ml \
	src/RamenReplay.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenMake.ml \
	src/RamenSupervisor.ml \
	src/RamenSampling.ml \
	src/CodeGenLib.ml \
	src/RamenOutRef.ml \
	src/RamenOCamlCompiler.ml \
	src/RamenStringExpansion.ml

# For the actual command line building all_tests.opt:
LINKED_FOR_TESTS = \
	src/RamenVersions.ml \
	src/RamenLog.ml \
	src/RamenAtomic.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenHelpers.ml \
	src/RamenTimeRange.ml \
	src/HeavyHitters.ml \
	src/RamenChannel.mli \
	src/RamenChannel.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypeConverters.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenNullable.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenLang.ml \
	src/RamenExpr.ml \
	src/RamenWatchdog.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenWorkerStats.ml \
	src/RamenWorkerStatsSerialization.ml \
	src/RamenNotification.ml \
	src/RamenNotificationSerialization.ml \
	src/Globs.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenParams.ml \
	src/RamenCompilConfig.ml \
	src/RamenRetention.ml \
	src/RamenDepLibs.ml \
	src/RamenHeap.ml \
	src/RamenSortBuf.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/CodeGen_Dessser.ml \
	src/RamenBitmask.ml \
	src/RamenSerialization.ml \
	src/HeavyHitters.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenConf.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTypingErrors.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_OCaml.ml \
	src/RamenSyncHelpers.ml \
	src/RamenOutRef.ml \
	src/RamenPaths.ml \
	src/RamenProcesses.ml \
	src/RamenCompiler.ml \
	src/RamenReplay.ml \
	src/RamenServices.ml \
	src/RamenArchivist.ml \
	src/RamenExport.ml \
	src/RamenTimeseries.ml \
	src/RamenRun.ml \
	src/RamenHttpHelpers.ml \
	src/RamenApi.ml \
	src/RamenMake.ml \
	src/RamenFileNotify.ml \
	src/RamenSupervisor.ml \
	src/RamenPs.ml \
	src/RamenBloomFilter.ml \
	src/RamenGraphite.ml \
	src/TestHelpers.ml \
	src/RamenNullable.ml \
	src/RamenSampling.ml \
	src/CodeGenLib.ml \
	src/CodeGenLib_IO.ml \
	src/RamenStringExpansion.ml

src/all_tests.ml: $(TESTABLE_SOURCES)
	@echo 'Generating unit tests into $@'
	$(QTEST) --shuffle -o $@ extract $^

all_tests.opt: \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		$(filter %.cmx,$(LINKED_FOR_TESTS:.ml=.cmx)) \
		src/all_tests.ml
	@echo 'Building unit tests into $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) -package qcheck $(filter %.cmx, $^) $(filter %.a, $^) $(filter %.ml, $^) -o $@

ringbuf_test.opt: \
		src/RamenVersions.cmx \
		src/RamenLog.cmx \
		src/RamenAtomic.cmx \
		src/RamenName.cmx \
		src/RamenConsts.cmx \
		src/RamenHelpers.cmx \
		src/RamenChannel.cmx \
		src/RamenFiles.cmx \
		src/RamenExperiments.cmx \
		src/RamenParsing.cmx \
		src/RamenEthAddr.cmx \
		src/RamenIpv4.cmx \
		src/RamenIpv6.cmx \
		src/RamenIp.cmx \
		src/RamenTypeConverters.cmx \
		src/RamenTypes.cmx \
		src/RamenAdvLock.cmx \
		src/RamenFieldMask.cmx \
		src/RamenUnits.cmx \
		src/RamenTuple.cmx \
		src/RingBuf.cmx \
		src/RingBufLib.cmx \
		src/RamenOrc.cmx \
		src/ringbuf_test.cmx \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a
	@echo 'Building ringbuf tests into $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/ringbuf/test: src/ringbuf/test.c src/libringbuf.a
	@echo 'Building ringbuf load test into $@'
	$(CC) $(CFLAGS) $(CPPFLAGS) -O0 -g $^ -o $@

check: unit-check cli-check func-check arc-check orc-check

unit-check: all_tests.opt ringbuf_test.opt
	@echo 'Running unit tests...'
	@TZ=CET OCAMLRUNPARAM=b ./all_tests.opt -bt
	@timeout 3 ./ringbuf_test.opt

cli-check: src/ramen bundle
	@echo 'Running CLI tests...'
	mkdir -p tests/results/cli-check
	cd tests && cucumber -f pretty -f junit -o results/cli-check/junit.xml

RAMEN_TESTS = $(wildcard tests/func/*.test)

RAMEN_TESTS_SOURCES = \
	$(RAMEN_TESTS:.test=.ramen) \
	$(wildcard tests/func/fixtures/*.ramen)

%.x: \
		%.ramen \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_DIR)/include/dessser \
		src/ramen \
		src/codegen.cmxa
	@echo 'Compiling ramen program $@'
	RAMEN_CONFSERVER= src/ramen compile --bundle=bundle -L . -L src -L tests/func $< -o $@

# Functional tests are not 100% reproductible:
%.success: %.test src/ramen bundle
	@echo 'Running test $(basename $< .test)'
	@$(RM) $@
	@RAMEN_CONFSERVER= src/ramen test --bundle-dir=bundle '$<' && touch $@

func-check: $(RAMEN_TESTS:.test=.success)

err-check: \
		src/ramen \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a \
		$(wildcard tests/errors/*.ramen) \
		$(wildcard tests/errors/*.err)
	@echo 'Running parsing/typing error tests'
	@for f in $(wildcard tests/errors/*.ramen); do \
	  t=$$(mktemp) ;\
	  RAMEN_CONFSERVER= src/ramen compile --quiet --bundle=bundle -L tests/errors $$f 2>&1 >/dev/null |\
	    sed 1d > $$t ;\
	  if ! diff -q $$f.err $$t ; then \
	    echo "\033[1;31mFAILURE\033[0m: $$f" ;\
	    exit 1 ;\
	  fi ;\
	  $(RM) $$t ;\
	done ;\
	echo "\033[1;32mSUCCESS\033[0m"

RAMEN_ARCHIVIST_TESTS = $(wildcard tests/archivist/*.allocs)

arc-check: src/ramen $(RAMEN_ARCHIVIST_TESTS)
	@echo 'Running storage allocation tests'
	@echo 'TODO: make it possible to upload the stats file in the confserver'

orc-check: src/orc/orc_writer $(wildcard tests/orc/*.type) $(wildcard tests/orc/*.data)
	@echo 'Checking ORC writes...'
	@failed="" ;\
	 for t in $(wildcard tests/orc/*.type); do \
	   base="$$(basename $$t .type)" ;\
	   echo "  Checking $$base" ;\
	   typ=$$(cat "$$t") ;\
	   data="$$(dirname $$t)/$$base.data" ;\
	   writer="/tmp/$$base" ;\
	   orc="/tmp/$$base.orc" ;\
	   csv="/tmp/$$base.csv" ;\
	   if ! (\
	     src/orc/orc_writer "$$writer" "$$typ" &&\
	     "$$writer" write "$$orc" < "$$data" &&\
	     "$$writer" read  "$$orc" > "$$csv" ;\
	   ) then \
	     echo "\033[1;31mFAILURE\033[0m: Cannot create CSV file for $$base" ;\
	     failed="$$failed $$base" ;\
	   else \
	     if diff -q "$$data" "$$csv"; then \
	       echo "\033[1;32mSUCCESS\033[0m" ;\
	     else \
	       echo "\033[1;31mFAILURE\033[0m: $$data and $$csv differ:" ;\
	       diff "$$data" "$$csv" ;\
	       failed="$$failed $$base" ;\
	     fi ;\
	   fi ;\
	 done ;\
	 if test -n "$$failed"; then \
	   echo "\033[1;31mFAILURE\033[0m:$$failed" ;\
	   exit 1 ;\
	 fi


# Installation

install: $(INSTALLED) install-bundle
	ocamlfind install ramen $(INSTALLED_LIB) META
	@echo 'Installing binaries into $(bin_dir)'
	install -d $(bin_dir)
	install $(INSTALLED_BIN) $(bin_dir)/
ifdef STRIP_BIN
	for f in $(INSTALLED_BIN); do \
	   strip $(bin_dir)/$$(basename $$f) || true ;\
	done
endif

# We need ocamlfind to find ramen package before we can install the lib bundle.
# Therefore we simply build it as a separate, optional step (that's only
# required if you intend to use the embedded compiler).
install-bundle: bundle
	@echo 'Installing libraries bundle into $(DESTDIR)$(lib_dir)'
	install -d $(DESTDIR)$(lib_dir)
	cp -r $(BUNDLE_DIR) $(DESTDIR)$(lib_dir)/

install-examples:
	@echo 'Installing examples into $(DESTDIR)$(sample_dir)'
	install -d $(DESTDIR)$(lib_dir)
	cd examples/programs &&\
	 find . -type f -name '*.ramen' \
	   -exec sh -c 'mkdir -p $(DESTDIR)$(sample_dir)/$$(dirname {})' \; \
	   -exec sh -c 'cp {} $(DESTDIR)$(sample_dir)/$$(dirname {})' \;

install-systemd:
	@echo 'Installing systemd configuration into $(DESTDIR)$(systemd_dir)'
	install -d $(DESTDIR)$(systemd_dir)
	install -d $(DESTDIR)$(sysconf_dir)
	cp systemd/*.target systemd/*.service $(DESTDIR)$(systemd_dir)
	cp systemd/ramen $(DESTDIR)$(sysconf_dir)

uninstall: uninstall-bundle
	ocamlfind remove ramen
	@echo 'Uninstalling binaries and libraries bundle'
	$(RM) $(bin_dir)/ramen

uninstall-bundle:
	@echo 'Uninstalling libraries bundle'
	$(RM) -r $(DESTDIR)$(lib_dir)/$(BUNDLE_DIR)

reinstall: uninstall install

# Debian package

deb: ramen.$(VERSION).deb

tarball: ramen.$(VERSION).tgz

ramen.$(VERSION).deb: \
		$(PACKAGED_BIN) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a \
		debian.control
	@echo 'Building debian package $@'
	rm -rf debtmp
	install -d debtmp/usr/bin
	install $(PACKAGED_BIN) debtmp/usr/bin
ifdef STRIP_BIN
	for f in $(PACKAGED_BIN); do strip debtmp/usr/bin/$$(basename $$f); done
endif
	$(MAKE) DESTDIR=$(PWD)/debtmp/ install-examples
	$(MAKE) DESTDIR=$(PWD)/debtmp/ install-bundle
	$(MAKE) DESTDIR=$(PWD)/debtmp/ install-systemd
	mkdir -p debtmp/DEBIAN
	cp debian.control debtmp/DEBIAN/control
	chmod -R a+x debtmp/usr
	fakeroot dpkg --build debtmp
	mv debtmp.deb $@

ramen.$(VERSION).tgz: \
		$(PACKAGED_BIN) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/lib/liborc.a
	@echo 'Building tarball $@'
	$(RM) -r tmp/ramen
	install -d tmp/ramen
	install $(PACKAGED_BIN) tmp/ramen/
	install @Z3@ tmp/ramen/
ifdef STRIP_BIN
	for f in $(PACKAGED_BIN); do strip tmp/ramen/$$(basename $$f); done
endif
	chmod -R a+x tmp/ramen/*
	$(MAKE) DESTDIR=$(PWD)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-examples
	$(MAKE) DESTDIR=$(PWD)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-bundle
	$(MAKE) DESTDIR=$(PWD)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-systemd
	tar c -C tmp ramen | gzip > $@

# Docker images:
# - docker builds the ramen docker image;
# - docker-dev builds the docker-dev image.

docker: docker/Dockerfile docker/ramen.$(VERSION).deb
	@echo 'Building docker image for testing DEB version'
	docker build -t rixed/ramen:latest --squash -f $< docker/
	@echo 'Pushing to local hub as localhost:5000/ramen'
	docker tag rixed/ramen localhost:5000/ramen
	docker push localhost:5000/ramen
	@if test `whoami` = rixed; then \
	   read -p "Also push rixed/ramen:latest to docker hub? [yn]" PUSH ;\
	   if test $$PUSH = y -o $$PUSH = Y; then \
	     docker push rixed/ramen:latest ;\
	   fi ;\
	 fi

DISTRIB_TAGS = \
	debian:stretch,stretch \
	debian:buster,buster \
	ubuntu:latest,ubuntu

docker-dev: docker/Dockerfile-dev
	@for distrib_tag in $(DISTRIB_TAGS) ; do \
	  distrib=`echo $$distrib_tag | cut -d, -f1` ;\
	  tag=`echo $$distrib_tag | cut -d, -f2` ;\
	  echo 'Building ramen-dev docker image from '$$distrib ;\
	  echo 'FROM '$$distrib > docker/Dockerfile-dev.$$tag ;\
	  cat docker/Dockerfile-dev >> docker/Dockerfile-dev.$$tag ;\
	  docker build -t rixed/ramen-dev:$$tag \
	               -f docker/Dockerfile-dev.$$tag docker/ ;\
	  $(RM) docker/Dockerfile-dev.$$tag ;\
	done
	@if test `whoami` = rixed; then \
	   read -p "Also push rixed/ramen-dev:* to docker hub? [yn]" PUSH ;\
	   if test $$PUSH = y -o $$PUSH = Y; then \
	     for distrib_tag in $(DISTRIB_TAGS) ; do \
	       tag=`echo $$distrib_tag | cut -d, -f2` ;\
	       docker push rixed/ramen-dev:$$tag ;\
	     done ;\
	   fi ;\
	 fi

# The docker image is build from the debian package:
docker/ramen.$(VERSION).deb: ramen.$(VERSION).deb
	@echo 'Copying debian package into docker/'
	cp $< $@

# Also for the docker image only. docker-dev builds its own z3.
docker/z3: @Z3@
	@echo 'Copying z3 from system into docker/'
	cp $< $@

# docker-push target will tag and push the images:
docker-push:
	@echo 'Tagging latest docker image to v$(VERSION)'
	docker tag rixed/ramen:latest rixed/ramen:v$(VERSION)
	@echo 'Uploading docker images'
	docker push rixed/ramen:latest
	docker push rixed/ramen:v$(VERSION)
	docker push rixed/ramen-dev:stretch
	docker push rixed/ramen-dev:buster

# Cleaning

clean-temp:
	@echo 'Cleaning ramen compiler temp files'
	for d in tests examples ; do\
	   find $$d -\( -name '*.cc' -o -name '*.ml' -o -name '*.cmx' \
	                -o -name '*.o' -o -name '*.annot' -o -name '*.cmt' \
	                -o -name '*.cmti' -o -name '*.x' -o -name '*.s' \
	                -o -name '*.cmi' -o -name '*.smt2' -\) \
	            -delete ;\
	 done

clean-dist: clean clean-temp
	@echo 'Cleaning all build files'
	$(RM) doc/tutorial.html doc/manual.html doc/roadmap.html
	$(RM) $(INSTALLED_RAMEN_PROGRAMS)
	find tests -name '*.success' -delete
	$(RM) -r $(BUNDLE_DIR)
	rm -rf debtmp
	$(RM) -r tmp
	$(RM) ramen.*.deb ramen.*.tgz
	$(RM) rmadmin/RmAdmin rmadmin/rmadmin.ico rmadmin/rmadmin.icns
	$(RM) rmadmin/rmadmin.pro
	$(RM) -r rmadmin/RmAdmin.app
	$(RM) $(PAGES)
	$(RM) META

clean:
	@echo 'Cleaning result'
	$(RM) src/*.s src/*.annot src/*.cmt src/*.cmti src/*.o
	$(RM) *.opt src/all_tests.* perf.data* gmon.out
	$(RM) src/ringbuf/*.o src/orc/*.o
	$(RM) src/*.cmx src/*.cmxa src/*.cmxs src/*.cmi src/*.cmo
	$(RM) src/orc/*.cmx src/orc/*.annot src/orc/*.cmt src/orc/*.cmxs src/orc/*.cmi
	$(RM) src/oUnit-anon.cache src/qtest.targets.log
	$(RM) .depend src/*.opt src/*.byte
	$(RM) src/RamenFileNotify.ml src/RamenCompilConfig.ml
	$(RM) src/ramen src/codegen.cmxa src/libringbuf.a src/liborchelp.a
ifeq ($(BUILD_RMADMIN),1)
	if test -e rmadmin/Makefile; then $(MAKE) -C rmadmin clean; fi
endif
	$(RM) rmadmin/*.o rmadmin/*.s rmadmin/*.annot rmadmin/*.cmx rmadmin/*.cmi
	$(RM) rmadmin/Makefile rmadmin/moc_* rmadmin/*.dmg
	$(RM) src/libcollectd.a src/libnetflow.a src/codegen.a

authn: src/RamenAuthn.cmx
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package batteries,zmq,sodium -linkpkg $(filter %.cmx, $^) -o $@
