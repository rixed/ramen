# Configuration

VERSION = @PACKAGE_VERSION@
BUNDLE_DIR = bundle

DUPS_IN  = $(shell ocamlfind query compiler-libs)
OCAMLC   = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamlc
OCAMLOPT = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamlopt
OCAMLDEP = OCAMLPATH=$(OCAMLPATH) OCAMLRUNPARAM= OCAMLFIND_IGNORE_DUPS_IN="$(DUPS_IN)" ocamlfind ocamldep
QTEST    = qtest
LINUXDEPLOY = linuxdeploy-x86_64.AppImage
WGET     = wget --quiet
# Alternatives: `docker buildx build --platform linux/amd64,linux/arm64 --push`
DOCKER_BUILD ?= docker build

WARNS    = -w -40-58+27
OCAMLOPTFLAGS = @OCAMLOPTFLAGS@ -thread -I src -I $(BUNDLE_DIR)/lib $(WARNS) -annot -bin-annot
OCAMLCFLAGS = @OCAMLCFLAGS@ -thread -I src -I $(BUNDLE_DIR)/lib $(WARNS) -annot

CFLAGS   += -std=gnu11   -Wall -W -Wno-parentheses -fPIC
CXXFLAGS += -std=gnu++17 -Wall -W -Wno-parentheses -fPIC
CPPFLAGS += -D_GNU_SOURCE \
            -I '@OCAMLLIB@' \
            -I '$(BUNDLE_DIR)/include' \
            -DHAVE_INT128 \
            -I '$(shell ocamlfind query stdint)'

ifdef NDEBUG
OCAMLOPTFLAGS += -noassert -O2
OCAMLCFLAGS += -noassert -O2
CPPFLAGS += -DNDEBUG
CFLAGS += -O3
CXXFLAGS += -DNDEBUG -O3
QMAKE_EXTRA = "CONFIG+=release"
STRIP_BIN = 1
CMAKE_BUILD_TYPE = "RELEASE"
else
OCAMLOPTFLAGS += -g
OCAMLCFLAGS += -g
CPPFLAGS += -g
CFLAGS += -O0
CXXFLAGS += -O0 -g
QMAKE_EXTRA = "CONFIG+=debug"
CMAKE_BUILD_TYPE = "DEBUG"
endif

# parsercombinator is used by string to IP conversion :(
META_REQUIRES = \
	batteries \
	binocle \
	binocle.thread \
	dessser \
	findlib \
	kafka \
	lacaml \
	lmdb \
	parsercombinator \
	pfds \
	ppp \
	ppp.unix \
	smt2 \
	sodium \
	stdint \
	syslog \
	threads
# The above are the dependencies required when ramen is running.
# To build ramen you will also need:
#   unix num js_of_ocaml js_of_ocaml-ppx cmdliner sqlite3
#   compiler-libs compiler-libs.common
#   compiler-libs.bytecomp compiler-libs.optcomp

PACKAGES = \
	batteries \
	binocle \
	binocle.thread \
	cmdliner \
	compiler-libs \
	compiler-libs.bytecomp \
	compiler-libs.common \
	compiler-libs.optcomp \
	dessser \
	kafka \
	lacaml \
	lmdb \
	parsercombinator \
	pfds \
	net_codecs \
	num \
	ppp \
	ppp.ppx \
	ppp.unix \
	smt2 \
	sodium \
	sqlite3 \
	stdint \
	syslog \
	threads \
	unix \
	uuidm

ifeq ($(shell uname),Darwin)
FILE_NOTIFIER = src/RamenFileNotify_Poller.ml
else
FILE_NOTIFIER = src/RamenFileNotify_Inotify.ml
META_REQUIRES += inotify
PACKAGES += inotify
endif

# `make` should compile and install everything, yet to build the deb or
# tarball is not needed:
PACKAGED_BIN = src/ramen
INSTALLED_BIN = $(PACKAGED_BIN)

INSTALLED_LIB = \
	src/codegen.cmxa src/codegen.a \
	$(filter %.cmi, $(CODEGENLIB_SOURCES:.ml=.cmi)) \
	$(filter %.cmx, $(CODEGENLIB_SOURCES:.ml=.cmx)) \
	src/libringbuf.a src/libcollectd.a src/libnetflow.a \
	src/liborchelp.a src/libcountry.a
INSTALLED = $(INSTALLED_BIN) $(INSTALLED_LIB) META

ifneq (@HAVE_ORC@,1)
BUNDLE_LIBORC = $(BUNDLE_DIR)/lib/liborc.a
else
BUNDLE_LIBORC =
endif

prefix = @prefix@
exec_prefix = @exec_prefix@
bin_dir ?= @bindir@
# Where the deb (or other non-opam) version of ramen will get the libraries
# bundle from. This is important that the ramen package is compiled with the
# correct path as we use opam installed libs to build the non-opam bundle,
# or RamenCompilConfig will be incompatible).
lib_dir ?= @libexecdir@

# Where examples are installed
sample_dir ?= @sharedstatedir@

# Where to install systemd configuration
systemd_dir ?= /lib/systemd/system
sysconf_dir ?= /etc/default

all: $(INSTALLED) bundle

# Rules depending in Makefile itself are offloaded in a distinct, rarely modified files:
include make.inc

# Generic rules

.SUFFIXES: .ml .mli .cmi .cmx .cmo .cmxs .cmt .top .html .adoc .ramen .alert \
           .pivot .x .test .success .type

.PHONY: clean clean-temp clean-dist clean-dessserc-gen clean-doc clean-dist-doc \
        all dep bundle doc deb tarball bundle \
        check func-check unit-check ringbuf-check cli-check err-check arc-check \
        orc-check comp-check examples-check examples-check-prep doc-check \
        install install-bundle install-examples install-systemd uninstall reinstall \
        docker docker-dev docker-push docker-dev-push appimage coverity bench

%.cmi: %.mli
	@echo 'Compiling $@ (interface)'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c '$<'

%.cmi: %.cmx
	@true

#src/RamenName.cmi: src/RamenName.mli
#	@echo 'Compiling $@ (interface)'
#	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c '$<'

%.cmx %.cmt: %.ml
	@echo 'Compiling $@ (native)'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package "$(PACKAGES)" -c '$<'

%.cmo %.cmt: %.ml
	@echo 'Compiling $@ (bytecode)'
	$(OCAMLC) $(OCAMLCFLAGS) -package "$(PACKAGES)" -c '$<'

%.html: %.adoc
	@echo 'Building documentation $@'
	asciidoc -a data-uri -a icons -a toc -a max-width=55em --theme volnitsky -o '$@' '$<'

%.ml: %.type
	@echo 'Generating code for type $<'
	@extra=""; \
	if test -n "$(findstring $<, $(TYPE_NEED_SEXPR))"; then \
	  extra="--input-encoding s-expression --output-encoding s-expression $$extra" ;\
	fi ;\
	if test -n "$(findstring $<, $(TYPE_NEED_JSON))"; then \
	  extra="--input-encoding json --output-encoding json $$extra" ;\
	fi ;\
	ocamlfind dessser/dessserc lib --quiet --fieldmask=both -O3 \
	  --input-encoding row-binary --output-encoding row-binary \
	  --language=OCaml --schema='@$<' \
	  $$extra -o '$@' ;\
	$(RM) '$(basename $@).mli'

# BEWARE that raql_type is not automatically generated
TYPE_SOURCES = \
	src/field_name_wire.type \
	src/field_name.ml \
	src/function_name_wire.type \
	src/function_name.ml \
	src/program_name_wire.type \
	src/program_name.ml \
	src/fq_name_wire.type \
	src/fq_name.ml \
	src/site_name_wire.type \
	src/site_name.ml \
	src/file_path_wire.type \
	src/file_path.ml \
	src/src_path_wire.type \
	src/src_path.ml \
	src/team_name_wire.type \
	src/team_name.ml \
	src/fieldmask_wire.type \
	src/fieldmask.ml \
	src/fq_function_name.type \
	src/event_time_field.type \
	src/event_time.type \
	src/raql_type_wire.type \
	src/raql_type.ml \
	src/raql_value_wire.type \
	src/raql_value.ml \
	src/func_ref.type \
	src/worker.type \
	src/units.type \
	src/global_variable.type \
	src/field_type.type \
	src/program_run_parameter.type \
	src/program_parameter.type \
	src/rc_entry.type \
	src/raql_variable.type \
	src/raql_path_comp.type \
	src/raql_top_output.type \
	src/raql_binding_key.type \
	src/raql_expr.type \
	src/raql_net_protocol.type \
	src/raql_ip_protocol.type \
	src/raql_select_field.type \
	src/raql_flush_method.type \
	src/raql_operation.type \
	src/retention.type \
	src/raql_error.type \
	src/raql_warning.type \
	src/source_info.type \
	src/simple_filter.type \
	src/alert.type \
	src/pivot.type \
	src/runtime_stats.type \
	src/time_range.type \
	src/sync_socket.type \
	src/sync_key.type \
	src/output_specs_wire.type \
	src/output_specs.ml \
	src/replay.type \
	src/replay_request.type \
	src/replayer.type \
	src/dashboard_widget.type \
	src/alerting_contact.type \
	src/alerting_notification.type \
	src/alerting_delivery_status.type \
	src/alerting_log.type \
	src/alerting_inhibition.type \
	src/sync_user_id.type \
	src/sync_selector.type \
	src/sync_value.type \
	src/sync_client_cmd.type \
	src/sync_client_msg.type \
	src/sync_server_msg.type \
	src/sync_msg.type

TYPE_NEED_SEXPR = \
	src/raql_value.type

TYPE_NEED_JSON = \
	src/fq_name_wire.type \
	src/site_name_wire.type \
	src/function_name_wire.type \
	src/program_name_wire.type \
	src/team_name_wire.type \
	src/team_wire.type \
	src/alerting_contact.type \
	src/alerting_notification.type \
	src/field_name_wire.type \
	src/simple_filter.type \
	src/alert.type \
	src/pivot.type

RAMEN_SOURCES = \
	src/RamenVersions.ml \
	src/RamenAtomic.ml \
	src/RamenHelpersNoLog.ml \
	src/RamenLog.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenConstsContentTypes.ml \
	src/RamenConstsMetric.ml \
	src/RamenConstsCliInfo.ml \
	src/RamenConstsWorkerCommands.ml \
	src/RamenConstsWorkerArgv0.ml \
	src/RamenConstsExitCodes.ml \
	src/RamenConstsFieldDocs.ml \
	src/RamenConstsServiceNames.ml \
	src/RamenConstsDefault.ml \
	src/RamenConstsObjectSuffixes.ml \
	src/RamenConstsEntryPoints.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenRaqlError.ml \
	src/RamenRaqlWarning.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	$(filter %.ml, $(TYPE_SOURCES:.type=.ml)) \
	src/RamenBitmask.ml \
	src/RamenChannel.ml \
	src/RamenTimeRange.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenParams.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenTuple.ml \
	src/RamenFieldOrder.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenTypeConverters.ml \
	src/RamenVariable.ml \
	src/RamenLang.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenExpr.ml \
	src/Globs.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenCompilConfig.ml \
	src/RamenRetention.ml \
	src/RamenSerialization.ml \
	src/RamenWatchdog.ml \
	src/HeavyHitters.ml \
	src/RamenDepLibs.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenAuthn.ml \
	src/RamenTcpSocket.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenConf.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTypingErrors.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_Helpers.ml \
	src/CodeGen_OCaml.ml \
	src/CodeGen_OCamlEnv.ml \
	src/CodeGen_RaQL2DIL.ml \
	src/CodeGen_Dessser.ml \
	src/RamenSyncHelpers.ml \
	src/RamenPaths.ml \
	src/RamenSyncUsers.ml \
	src/RamenOutRef.ml \
	src/RamenServices.ml \
	src/RamenFileNotify.ml \
	src/RamenProcesses.ml \
	src/RamenSubcommands.ml \
	src/RamenCompiler.ml \
	src/RamenReplay.ml \
	src/RamenArchivist.ml \
	src/RamenExport.ml \
	src/RamenTimeseries.ml \
	src/RamenHttpHelpers.ml \
	src/RamenGc.ml \
	src/RamenRun.ml \
	src/RamenGraphite.ml \
	src/CodeGen_SimpleFilter2RaQL.ml \
	src/CodeGen_Alert2RaQL.ml \
	src/CodeGen_Pivot2RaQL.ml \
	src/RamenApi.ml \
	src/RamenMake.ml \
	src/RamenSupervisor.ml \
	src/RamenHeap.ml \
	src/RamenSzHeap.ml \
	src/SqliteHelpers.ml \
	src/RamenStringExpansion.ml \
	src/RamenAlerter.ml \
	src/TermTable.ml \
	src/RamenHttpd.ml \
	src/RamenCopy.ml \
	src/RamenCopySrv.ml \
	src/RamenSyncServer.ml \
	src/RamenSourceExamples.ml \
	src/RamenSyncZMQServer.ml \
	src/RamenChoreographer.ml \
	src/RamenReplayService.ml \
	src/RamenPrecompserver.ml \
	src/RamenExecompserver.ml \
	src/RamenConfClient.ml \
	src/RamenCliCheck.ml \
	src/RamenTestAlert.ml \
	src/RamenCliCmd.ml \
	src/RingBufCmd.ml \
	src/RamenCompletion.ml \
	src/RamenTests.ml \
	src/ramen.ml

CODEGENLIB_SOURCES = \
	src/RamenVersions.ml \
	src/RamenAtomic.ml \
	src/RamenHelpersNoLog.ml \
	src/RamenLog.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenConstsExitCodes.ml \
	src/RamenConstsMetric.ml \
	src/RamenConstsDefault.ml \
	src/RamenConstsFieldDocs.ml \
	src/RamenConstsWorkerCommands.ml \
	src/RamenConstsWorkerArgv0.ml \
	src/Globs.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenRaqlError.ml \
	src/RamenRaqlWarning.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	$(filter %.ml, $(TYPE_SOURCES:.type=.ml)) \
	src/RamenChannel.ml \
	src/CountryOfIp.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenWatchdog.ml \
	src/RamenAdvLock.ml \
	src/RamenFieldMask.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RingBuf.ml \
	src/RamenTypeConverters.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenTuple.ml \
	src/RamenFieldOrder.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenBloomFilter.ml \
	src/RamenSampling.ml \
	src/RamenFileNotify.ml \
	src/RamenParams.ml \
	src/RamenVariable.ml \
	src/RamenLang.ml \
	src/RamenExpr.ml \
	src/RamenProtocols.ml \
	src/RamenOperation.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenTimeRange.ml \
	src/RamenRetention.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenAuthn.ml \
	src/RamenTcpSocket.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenCompilConfig.ml \
	src/RamenConf.ml \
	src/RamenHeap.ml \
	src/RamenSzHeap.ml \
	src/RamenSortBuf.ml \
	src/HeavyHitters.ml \
	src/RamenOutRef.ml \
	src/CodeGenLib.ml \
	src/CodeGenLib_Config.ml \
	src/CodeGenLib_Factors.ml \
	src/CodeGenLib_Stats.ml \
	src/CodeGenLib_IO.ml \
	src/CodeGenLib_State.ml \
	src/CodeGenLib_Casing.ml \
	src/CodeGenLib_Publish.ml \
	src/CodeGenLib_Globals.ml \
	src/CodeGenLib_Dessser.ml \
	src/RamenCopy.ml \
	src/RamenCopyClt.ml \
	src/CodeGenLib_Skeletons.ml

LIBRINGBUF_SOURCES = \
	src/config.h \
	src/ringbuf/archive.h \
	src/ringbuf/archive.c \
	src/ringbuf/miscmacs.h \
	src/ringbuf/ringbuf.h \
	src/ringbuf/ringbuf.c \
	src/ringbuf/wrappers.c

LIBCOLLECTD_SOURCES = \
	src/collectd/collectd.h \
	src/collectd/collectd.c \
	src/collectd/wrappers.c

LIBNETFLOW_SOURCES = \
	src/netflow/v5.c

LIBORC_SOURCES = \
	src/orc/wrappers.cc

LIBCOUNTRY_SOURCES = \
	src/country_of_ip/country_of_ip.h \
	src/country_of_ip/country_of_ip.c \
	src/country_of_ip/db.h \
	src/country_of_ip/db_v4.h \
	src/country_of_ip/db_v4.c \
	src/country_of_ip/db_v6.h \
	src/country_of_ip/db_v6.c \
	src/country_of_ip/wrapper.c

ORCWRITER_SOURCES = \
	src/RamenVersions.ml \
	src/RamenAtomic.ml \
	src/RamenHelpersNoLog.ml \
	src/RamenLog.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenConstsExitCodes.ml \
	src/RamenConstsMetric.ml \
	src/RamenConstsDefault.ml \
	src/RamenConstsFieldDocs.ml \
	src/RamenConstsObjectSuffixes.ml \
	src/RamenConstsEntryPoints.ml \
	src/RamenConstsWorkerCommands.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenRaqlError.ml \
	src/RamenRaqlWarning.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	$(filter %.ml, $(TYPE_SOURCES:.type=.ml)) \
	src/RamenTimeRange.ml \
	src/Globs.ml \
	src/RamenChannel.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenParams.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenFieldOrder.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenVariable.ml \
	src/RamenLang.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenExpr.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenCompilConfig.ml \
	src/RamenRetention.ml \
	src/RamenSerialization.ml \
	src/RamenDepLibs.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenAuthn.ml \
	src/RamenTcpSocket.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenConf.ml \
	src/RamenTypingErrors.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_Helpers.ml \
	src/CodeGen_OCaml.ml \
	src/CodeGen_OCamlEnv.ml \
	src/CodeGen_RaQL2DIL.ml \
	src/CodeGen_Dessser.ml \
	src/RamenOutRef.ml \
	src/RamenPaths.ml \
	src/RamenProcesses.ml \
	src/RamenCompiler.ml \
	src/orc/orc_writer.ml

TESTONLY_SOURCES = \
	src/TestHelpers.ml \
	src/ringbuf_test.ml \
	src/heavyhitters_test.ml \
	src/ringbuf/test.c

TOOLS_SOURCES = \
	tools/ipcsv.ml \
	tools/gen_reader_test.ml

SOURCES = $(sort \
	$(RAMEN_SOURCES) \
	$(CODEGENLIB_SOURCES) \
	$(LIBRINGBUF_SOURCES) \
	$(LIBRINGBUF_OCAML_SOURCES) \
	$(LIBCOLLECTD_SOURCES) \
	$(LIBNETFLOW_SOURCES) \
	$(ORCWRITER_SOURCES) \
	$(LIBORC_SOURCES) \
	$(TESTONLY_SOURCES) \
	$(LIBCOUNTRY_SOURCES) \
	$(TOOLS_SOURCES) \
)


# Dependencies

depend: \
		$(patsubst %.type, %.ml, $(filter %.type, $(TYPE_SOURCES))) \
		src/country_of_ip/db_v4.h src/country_of_ip/db_v6.h \
		src/RamenFileNotify.ml
	$(OCAMLDEP) -I src -package "$(PACKAGES)" $(filter %.ml, $(SOURCES)) $(filter %.mli, $(SOURCES)) > depend
	@for f in $(filter %.c, $(SOURCES)); do \
	  $(CC) $(CFLAGS) $(CPPFLAGS) -MM -MT "$$(dirname $$f)/$$(basename $$f .c).o" $$f >> depend ;\
	done

dep:
	$(RM) depend
	$(MAKE) depend

include depend

# Also the deps of some test programs to help individual compilation

tests/func/basic_aggr.x: tests/func/fixtures/cars.x tests/func/fixtures/n123.x
tests/func/case.x: tests/func/fixtures/n123.x
tests/func/commit_before.x: tests/func/fixtures/n123.x tests/func/fixtures/cars.x
tests/func/count.x: tests/func/fixtures/cars.x
tests/func/count_lines.x: tests/func/fixtures/n123.x
tests/func/fit_multi.x: tests/func/fixtures/cars.x
tests/func/fun_with_funcs.x: tests/func/fixtures/cars.x
tests/func/globals_program.x: tests/func/fixtures/cars.x
tests/func/groups.x: tests/func/fixtures/cars.x
tests/func/histogram.x: tests/func/fixtures/cars.x
tests/func/ip.x: tests/func/fixtures/mixture.x
tests/func/lag.x: tests/func/fixtures/n123.x
tests/func/last.x: tests/func/fixtures/earthquakes.x tests/func/fixtures/cars.x
tests/func/local_state_in_where_slow.x: tests/func/fixtures/cars.x
tests/func/moveavg.x: tests/func/fixtures/n123.x
tests/func/params.x: tests/func/fixtures/earthquakes.x
tests/func/past.x: tests/func/fixtures/earthquakes.x
tests/func/patterns.x: tests/func/fixtures/cars.x
tests/func/port_scan.x: tests/func/fixtures/port_scan.x
tests/func/rowbinary.x: tests/func/fixtures/udp.x
tests/func/sample.x: tests/func/fixtures/n123.x
tests/func/season.x: tests/func/fixtures/earthquakes.x
tests/func/sort.x: tests/func/fixtures/earthquakes.x
tests/func/top_expr.x: tests/func/fixtures/cars.x
tests/func/tuples.x: tests/func/fixtures/n123.x
tests/func/array_of_strings.x: tests/func/fixtures/email.x


# GeoIP database
# We use the one from http://software77.net/geo-ip/

IpToCountry.csv.gz:
	@echo 'Downloading $@'
	$(WGET) 'http://software77.net/geo-ip/?DL=1' -O '$@.tmp' && mv '$@.tmp' '$@'

IpToCountry.csv: IpToCountry.csv.gz
	@echo 'Uncompressing $@'
	gunzip --keep '$<' && touch '$@'

IpToCountry.6R.csv.gz:
	@echo 'Downloading $@'
	$(WGET) 'http://software77.net/geo-ip/?DL=7' -O '$@.tmp' && mv '$@.tmp' '$@'

IpToCountry.6R.csv: IpToCountry.6R.csv.gz
	@echo 'Uncompressing $@'
	gunzip --keep '$<' && touch '$@'

tools/ipcsv.opt: tools/ipcsv.ml
	@echo 'Compiling $@'
	$(OCAMLOPT) -linkpkg -package ipaddr,csv,str -o '$@' '$<'


# Compile Ramen

src/RamenFileNotify.ml: $(FILE_NOTIFIER)
	@echo 'Using implementation $(FILE_NOTIFIER) for new file notifications'
	@ln -sf '$(notdir $<)' '$@'
	@touch '$@'

src/libringbuf.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBRINGBUF_SOURCES)))
	@echo 'Building ringbuf library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs '$@' $^ >/dev/null

src/libcollectd.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBCOLLECTD_SOURCES)))
	@echo 'Building collectd library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs '$@' $^ >/dev/null

src/libnetflow.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBNETFLOW_SOURCES)))
	@echo 'Building netflow library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs '$@' $^ >/dev/null

src/liborchelp.a: $(patsubst %.cc,%.o,$(filter %.cc, $(LIBORC_SOURCES)))
	@echo 'Building orc helper library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs '$@' $^ >/dev/null

src/libcountry.a: $(patsubst %.c,%.o,$(filter %.c, $(LIBCOUNTRY_SOURCES)))
	@echo 'Building geolocation library'
	@sleep 1 # ar truncate mtime !?
	@$(AR) rs '$@' $^ >/dev/null

submodules/orc/NOTICE: .gitmodules
	@echo "Getting submodules"
	@git submodule init
	@git submodule update --depth 1
	@touch '$@'

ifneq (@HAVE_ORC@,1)
# We need the ORC include files to be installed for that one:
src/orc/wrappers.o: $(BUNDLE_DIR)/lib/liborc.a

$(BUNDLE_DIR)/lib/liborc.a: $(BUNDLE_DIR)/date submodules/orc/NOTICE
	@echo 'Building liborc'
	@mkdir -p submodules/orc/build
	@cd submodules/orc/build &&\
	 CPPFLAGS='$(CFLAGS) $(CPPFLAGS)' cmake .. \
	    -DBUILD_JAVA=OFF \
	    -DBUILD_LIBHDFSPP=OFF \
	    -DBUILD_CPP_TESTS=OFF \
	    -DBUILD_TOOLS=OFF \
	    -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE) \
	    -DCMAKE_INSTALL_PREFIX:PATH=$(CURDIR)/$(BUNDLE_DIR) \
	    -DSTOP_BUILD_ON_WARNING=OFF &&\
	 make install
	@touch '$@'
endif

$(BUNDLE_DIR)/include/caml:
	@echo 'Copying OCaml headers'
	@install -d '$(BUNDLE_DIR)/include'
	@cp -r '$(shell ocamlfind ocamlc -where)/caml' '$(BUNDLE_DIR)/include'

$(BUNDLE_DIR)/include/dessser:
	@echo 'Copying Dessser headers'
	@install -d '$(BUNDLE_DIR)/include/dessser'
	@cp $(wildcard $(shell ocamlfind query dessser)/*.h) '$(BUNDLE_DIR)/include/dessser/'

# We have to force -cclib -lstdint_stubs right after -cclib wrap_ringbuf.o
# otherwise -package stdint would put it before and gcc would not include the
# symbols we need as we are the only users.
MOREFLAGS = \
	-package "$(PACKAGES)" \
	-cclib -lstdint_stubs \
	-cclib -lorchelp \
	-cclib -lringbuf \
	-cclib -lcollectd \
	-cclib -lnetflow \
	-cclib -lorc \
	-cclib -lcountry \
	-cclib -llz4 \
	-cclib -lprotobuf \
	-cclib -lzstd \
	-cclib -lsnappy \
	-cclib -lz \
	-cclib -lsasl2

ifeq ($(shell uname),Darwin)
MOREFLAGS += \
	-cclib -lstdc++
else
MOREFLAGS += \
	-cclib -lcrypto \
	-cclib -lstdc++
endif

src/orc/orc_writer: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(ORCWRITER_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter %.ml, $(ORCWRITER_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_LIBORC)
	@echo 'Linking $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o '$@'

src/ramen: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(RAMEN_SOURCES))) \
		$(patsubst %.ml,%.cmx,$(filter %.ml, $(RAMEN_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_LIBORC)
	@echo 'Linking $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o '$@'

src/ramen.byte: \
		$(patsubst %.mli,%.cmi,$(filter %.mli, $(RAMEN_SOURCES))) \
		$(patsubst %.ml,%.cmo,$(filter %.ml, $(RAMEN_SOURCES))) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a
	@echo 'Linking $@'
	$(OCAMLC) $(OCAMLCFLAGS) -linkpkg $(MOREFLAGS) -cclib -lsodium -cclib -lsodium_stubs $(filter %.cmo, $^) -o '$@'

src/codegen.cmxa: \
		$(filter %.cmx,$(CODEGENLIB_SOURCES:.ml=.cmx)) \
		$(filter %.cmi,$(CODEGENLIB_SOURCES:.ml=.cmi)) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a
	@echo 'Linking runtime library $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -a $(MOREFLAGS) $(filter %.cmx, $^) -o '$@'

src/codegen.cma: \
		$(filter %.cmo,$(CODEGENLIB_SOURCES:.ml=.cmo)) \
		$(filter %.cmi,$(CODEGENLIB_SOURCES:.ml=.cmi)) \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a
	@echo 'Linking runtime library $@'
	$(OCAMLC) $(OCAMLCFLAGS) -a $(MOREFLAGS) $(filter %.cmo, $^) -o '$@'

src/codegen.a: src/codegen.cmxa

# Bundle directory

bundle: \
		$(BUNDLE_LIBORC) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_DIR)/include/dessser

$(BUNDLE_DIR)/date:
	@echo '!!! REBUILDING $(BUNDLE_DIR) !!!'
	$(RM) -r '$(BUNDLE_DIR)'
	mkdir -p '$(BUNDLE_DIR)'
	touch '$@'

$(BUNDLE_DIR)/ramen/codegen.a: $(BUNDLE_DIR)/date $(INSTALLED_LIB)
	@echo 'Bundling libs together into $(BUNDLE_DIR)'
	$(RM) -r '$(BUNDLE_DIR).tmp'
	mkdir '$(BUNDLE_DIR).tmp'
	@set -e ;\
	 deps=$$( \
	   for p in $(META_REQUIRES) ; do \
	     ocamlfind query -recursive -predicates native,mt -format '%d' $$p ;\
	   done | sort -u | grep -v /findlib) ;\
	 for d in $$deps ; do cp -r "$$d" '$(BUNDLE_DIR).tmp/' ; done
	mkdir '$(BUNDLE_DIR).tmp/ramen'
	cp $(INSTALLED_LIB) '$(BUNDLE_DIR).tmp/ramen'
	find '$(BUNDLE_DIR).tmp' -type f -not '(' \
	    -name '*.cmx*' -o -name '*.cmi' -o -name '*.a' -o \
	    -name '*.so' -o -name '*.o' -o -name META \
	  ')' -delete
	find '$(BUNDLE_DIR).tmp' -empty -delete
	@# Delete some of the biggest unused files:
	$(RM) '$(BUNDLE_DIR).tmp'/batteries/batteriesExceptionless.cm*
	$(RM) -r '$(BUNDLE_DIR).tmp'/ocaml/compiler-libs
	$(RM) -r '$(BUNDLE_DIR).tmp'/ocaml/camlp4
	$(RM) -r '$(BUNDLE_DIR).tmp'/ocaml/ocamldoc
	$(RM) -r '$(BUNDLE_DIR).tmp'/ocaml/thread
	$(RM) -r '$(BUNDLE_DIR).tmp'/ocaml/ocplib*
	$(RM) '$(BUNDLE_DIR).tmp'/ocaml/camlinternalFormat.*
	$(RM) '$(BUNDLE_DIR).tmp'/ocaml/*spacetime*
	@# Delete everything that's not from liborc:
	mkdir -p '$(BUNDLE_DIR)'
	find '$(BUNDLE_DIR)' -maxdepth 1 -mindepth 1 -type d -not '(' \
	    -name lib -o -name include \
		')' -exec rm -rf '{}' \;
	mv '$(BUNDLE_DIR).tmp'/* '$(BUNDLE_DIR)/'
	$(RM) -r '$(BUNDLE_DIR).tmp'
	touch '$@'

src/RamenSubcommands.ml: genRamenSubcommands.opt
	@echo 'Generating $@'
	./genRamenSubcommands.opt > '$@.tmp' && mv '$@.tmp' '$@'

# Not taken care of by `make dep`:
src/RamenSubcommands.cmx: src/RamenName.cmx src/RamenProcesses.cmx
src/RamenSubcommands.cmo: src/RamenName.cmo src/RamenProcesses.cmo

genRamenSubcommands.opt: \
		src/RamenVersions.cmx \
		src/RamenHelpersNoLog.cmx \
		src/RamenConstsCliInfo.cmx \
		src/genRamenSubcommands.ml
	@echo 'Linking $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg -package batteries,dessser,stdint,binocle $^ -o '$@'


#
# Documentation
#

GENERATED_EXPRS = \
	now random pi age cast force peek length lower upper uuid_of_u128 not abs \
	neg is-null exp log log10 sqrt sq ceil floor round cos sin tan acos asin \
	atan cosh sinh tanh hash parse_time chr like fit countrycode ipfamily \
	basename min max coalesce add sub mul div idiv mod pow truncate reldiff \
	and or comparison strict-comparison equality concat startswith endswith \
	bit-and bit-or bit-xor bit-shift in format_time index percentile substring \
	aggrmin aggrmax aggrsum aggravg aggrand aggror aggrbitand aggrbitor \
	aggrbitxor aggrfirst aggrlast aggrhistogram group count distinct lag \
	smooth sample one-out-of moveavg hysteresis once-every remember largest \
	top past split

GENERATED_PAGES = \
	$(addprefix site/raql/, $(addsuffix .html, $(GENERATED_EXPRS))) \
	doc/raql/toc.html

site/raql:
	mkdir -p site/raql

doc: site/raql $(GENERATED_PAGES)

doc/gen_doc.cmo: doc/gen_doc.ml doc/raql/expr.cmo
	ocamlfind ocamlc -annot -package batteries,owww -I doc/raql -c '$<' -o '$@'

doc/raql/expr.cmo: doc/raql/expr.ml
	ocamlfind ocamlc -annot -package batteries,owww -I doc/raql -c '$<' -o '$@'

doc/gen_doc.byte: doc/raql/expr.cmo doc/gen_doc.cmo
	ocamlfind ocamlc -annot -package batteries,owww -linkpkg $^ -o '$@'

clean-doc:
	for d in doc site/raql; do $(RM) $$d/*.cmo $$d/*.o $$d/*.cmt $$d/*.cmi; done

clean-dist-doc:
	$(RM) doc/gen_doc.byte
	$(RM) doc/doc.qrc
	$(RM) $(GENERATED_PAGES)

site/raql/%.html: doc/gen_doc.byte
	@doc/gen_doc.byte '$@'

doc/doc.qrc: $(GENERATED_PAGES) doc/gen_doc.byte
	@doc/gen_doc.byte '$@'

doc/raql/toc.html: doc/gen_doc.byte
	@doc/gen_doc.byte '$@'


#
# Tests
#

tools/ip2num_csv.opt: tools/ip2num_csv.ml
	@echo 'Compiling $@'
	$(OCAMLOPT) -linkpkg -package batteries -o '$@' '$<'

TESTABLE_SOURCES = \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	src/RamenTypes.ml \
	src/RamenName.ml \
	src/RamenTimeRange.ml \
	src/RamenExpr.ml \
	src/RamenGraphiteSink.ml \
	src/Globs.ml \
	src/RamenConstsDefault.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenTypingHelpers.ml \
	src/RamenProgram.ml \
	src/HeavyHitters.ml \
	src/RamenAtomic.ml \
	src/RamenHelpersNoLog.ml \
	src/RamenConstsExitCodes.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenHttpHelpers.ml \
	src/RamenBloomFilter.ml \
	src/CodeGen_OCaml.ml \
	src/CodeGen_RaQL2DIL.ml \
	src/CodeGen_Dessser.ml \
	src/RamenSortBuf.ml \
	src/RamenGraphite.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/RamenSerialization.ml \
	src/RamenSmtParser.ml \
	src/RamenUnits.ml \
	src/RamenTypeConverters.ml \
	src/RamenServices.ml \
	src/RamenProcesses.ml \
	src/RamenReplay.ml \
	src/RamenSyncIntf.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenAuthn.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenSyncZMQServer.ml \
	src/RamenMake.ml \
	src/RamenSupervisor.ml \
	src/RamenSampling.ml \
	src/CodeGenLib.ml \
	src/RamenOutRef.ml \
	src/RamenOCamlCompiler.ml \
	src/RamenStringExpansion.ml \
	src/RamenAlerter.ml

# For the actual command line building all_tests.opt:
LINKED_FOR_TESTS = \
	src/RamenVersions.ml \
	src/RamenAtomic.ml \
	src/RamenHelpersNoLog.ml \
	src/RamenLog.ml \
	src/RamenName.mli \
	src/RamenName.ml \
	src/RamenConsts.ml \
	src/RamenConstsExitCodes.ml \
	src/RamenConstsMetric.ml \
	src/RamenConstsFieldDocs.ml \
	src/RamenConstsDefault.ml \
	src/RamenConstsObjectSuffixes.ml \
	src/RamenConstsEntryPoints.ml \
	src/RamenConstsContentTypes.ml \
	src/RamenConstsWorkerCommands.ml \
	src/RamenConstsWorkerArgv0.ml \
	src/RamenConstsServiceNames.ml \
	src/RamenHelpers.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenRaqlError.ml \
	src/RamenRaqlWarning.ml \
	src/RamenParsing.ml \
	src/RamenEthAddr.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/RamenIp.ml \
	$(filter %.ml, $(TYPE_SOURCES:.type=.ml)) \
	src/RamenTimeRange.ml \
	src/HeavyHitters.ml \
	src/RamenChannel.ml \
	src/RamenTypeConverters.ml \
	src/RamenTypes.ml \
	src/RamenGlobalVariables.ml \
	src/RamenAdvLock.ml \
	src/RamenEventTime.ml \
	src/RamenUnits.ml \
	src/RamenTypeConverters.ml \
	src/RamenTuple.ml \
	src/RamenFieldOrder.ml \
	src/RamenCollectd.ml \
	src/RamenCollectdSerialization.ml \
	src/RamenNetflow.ml \
	src/RamenNetflowSerialization.ml \
	src/RamenGraphiteSink.ml \
	src/RamenProtocols.ml \
	src/RamenVariable.ml \
	src/RamenLang.ml \
	src/RamenExpr.ml \
	src/RamenWatchdog.ml \
	src/RingBuf.ml \
	src/RingBufLib.ml \
	src/RamenOrc.ml \
	src/Globs.ml \
	src/RamenOperation.ml \
	src/RamenFieldMask.ml \
	src/RamenFieldMaskLib.ml \
	src/RamenParams.ml \
	src/RamenCompilConfig.ml \
	src/RamenRetention.ml \
	src/RamenDepLibs.ml \
	src/RamenHeap.ml \
	src/RamenSortBuf.ml \
	src/RamenSyncTree.ml \
	src/RamenSyncIntf.ml \
	src/RamenBitmask.ml \
	src/RamenSerialization.ml \
	src/HeavyHitters.ml \
	src/RamenSyncClient.ml \
	src/RamenSyncUser.ml \
	src/RamenSync.ml \
	src/RamenSmtParser.ml \
	src/RamenSmt.ml \
	src/RamenAuthn.ml \
	src/RamenTcpSocket.ml \
	src/RamenSyncZMQClient.ml \
	src/RamenConf.ml \
	src/RamenTypingHelpers.ml \
	src/RamenTypingErrors.ml \
	src/RamenTyping.ml \
	src/RamenProgram.ml \
	src/RamenOCamlCompiler.ml \
	src/CodeGen_Helpers.ml \
	src/CodeGen_OCaml.ml \
	src/CodeGen_OCamlEnv.ml \
	src/CodeGen_RaQL2DIL.ml \
	src/CodeGen_Dessser.ml \
	src/RamenSyncHelpers.ml \
	src/RamenOutRef.ml \
	src/RamenPaths.ml \
	src/RamenProcesses.ml \
	src/RamenCompiler.ml \
	src/RamenReplay.ml \
	src/RamenServices.ml \
	src/RamenArchivist.ml \
	src/RamenSyncServer.ml \
	src/RamenSourceExamples.ml \
	src/RamenSyncZMQServer.ml \
	src/RamenExport.ml \
	src/RamenTimeseries.ml \
	src/RamenRun.ml \
	src/RamenHttpHelpers.ml \
	src/CodeGen_SimpleFilter2RaQL.ml \
	src/CodeGen_Alert2RaQL.ml \
	src/CodeGen_Pivot2RaQL.ml \
	src/RamenApi.ml \
	src/RamenMake.ml \
	src/RamenFileNotify.ml \
	src/RamenSupervisor.ml \
	src/RamenBloomFilter.ml \
	src/RamenGraphite.ml \
	src/TestHelpers.ml \
	src/RamenSampling.ml \
	src/CodeGenLib.ml \
	src/CodeGenLib_IO.ml \
	src/RamenStringExpansion.ml \
	src/SqliteHelpers.ml \
	src/RamenAlerter.ml

src/all_tests.ml: $(TESTABLE_SOURCES)
	@echo 'Generating unit tests into $@'
	$(QTEST) --shuffle -o '$@' extract $^

all_tests.opt: \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a \
		$(filter %.cmx,$(LINKED_FOR_TESTS:.ml=.cmx)) \
		src/all_tests.ml
	@echo 'Building unit tests into $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) -package qcheck $(filter %.cmx, $^) $(filter %.a, $^) $(filter %.ml, $^) -o $@

ringbuf_test.opt: \
		src/RamenVersions.cmx \
		src/RamenAtomic.cmx \
		src/RamenHelpersNoLog.cmx \
		src/RamenLog.cmx \
		src/RamenName.cmx \
		src/RamenConsts.cmx \
		src/RamenConstsExitCodes.cmx \
		src/RamenConstsDefault.cmx \
		src/RamenConstsExitCodes.cmx \
		src/RamenHelpers.cmx \
		src/RamenFiles.cmx \
		src/RamenExperiments.cmx \
		src/RamenRaqlError.cmx \
		src/RamenRaqlWarning.cmx \
		src/RamenParsing.cmx \
		src/RamenEthAddr.cmx \
		src/RamenIpv4.cmx \
		src/RamenIpv6.cmx \
		src/RamenIp.cmx \
		$(filter %.cmx, $(patsubst %.ml, %.cmx, $(TYPE_SOURCES:.type=.ml))) \
		src/RamenChannel.cmx \
		src/RamenTypeConverters.cmx \
		src/RamenTypes.cmx \
		src/RamenAdvLock.cmx \
		src/RamenFieldMask.cmx \
		src/RamenUnits.cmx \
		src/RamenTuple.cmx \
		src/RingBuf.cmx \
		src/RingBufLib.cmx \
		src/RamenOrc.cmx \
		src/ringbuf_test.cmx \
		src/libringbuf.a \
		src/libcollectd.a \
		src/libnetflow.a \
		src/liborchelp.a \
		src/libcountry.a
	@echo 'Building ringbuf tests into $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg $(MOREFLAGS) $(filter %.cmx, $^) -o $@

src/ringbuf/test: src/ringbuf/test.c src/libringbuf.a
	@echo 'Building ringbuf load test into $@'
	$(CC) $(CFLAGS) $(CPPFLAGS) -O0 -g $^ -o '$@'

heavyhitters_test.opt: \
		src/RamenAtomic.cmx \
		src/RamenHelpersNoLog.cmx \
		src/RamenLog.cmx \
		src/HeavyHitters.cmx \
		src/heavyhitters_test.cmx
	@echo 'Building $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg -package "$(PACKAGES)" $(filter %.cmx, $^) -o '$@'

check: \
		unit-check ringbuf-check cli-check func-check comp-check arc-check \
		orc-check examples-check err-check doc-check

unit-check: all_tests.opt
	@echo 'Running unit tests...'
	@TZ=CET OCAMLRUNPARAM=b ./all_tests.opt -bt

ringbuf-check: ringbuf_test.opt
	@echo 'Running ringbuffer tests...'
	@timeout 30 ./ringbuf_test.opt

# Those packages are required (under Debian) to run cli-check: socat, cucumber and ruby-rspec
cli-check: src/ramen bundle
	@echo 'Running CLI tests...'
	mkdir -p tests/results/cli-check
	cd tests && cucumber -f pretty -f junit -o results/cli-check/junit.xml

examples/monitoring/network/security.x: \
	examples/monitoring/network/traffic.x
examples/generators/network/aggregated.x: \
	examples/generators/network/logs.x
examples/generators/network/resp_time.x: \
	examples/generators/network/aggregated.x
examples/generators/network/errors.x: \
	examples/generators/network/aggregated.x
examples/generators/network/error_rate.x: \
	examples/generators/network/errors.x
examples/generators/network/error_rate.x: \
	examples/generators/network/errors.x
examples/monitoring/network/minutely.x: \
	examples/monitoring/network/hosts.x

examples-check:
	$(RM) examples/monitoring/network/minutely.ramen
	$(RM) examples/generators/network/resp_time.ramen
	$(RM) examples/generators/network/error_rate.ramen
	$(MAKE) \
		examples/monitoring/network/hosts.x \
		examples/monitoring/network/security.x \
		examples/monitoring/network/traffic.x \
		examples/monitoring/network/minutely.x \
		examples/generators/network/aggregated.x \
		examples/generators/network/resp_time.x \
		examples/generators/network/logs.x \
		examples/generators/network/errors.x \
		examples/generators/network/error_rate.x \
		examples/generators/network/logs_fast.x \
		examples/generators/basic.x \
		examples/tests/central_limit.x \
		examples/tests/noise.x \
		examples/tests/qps.x \
		examples/tests/seq.x \
		examples/tests/simplest.x

GENERATED_DOC_TESTS = \
	$(addsuffix .test, $(addprefix doc/raql/, \
		$(filter-out now random age lag smooth sample one-out-of moveavg hysteresis \
		             once-every remember largest top past split, \
			$(GENERATED_EXPRS))))

doc/raql/%.test: doc/gen_doc.byte
	doc/gen_doc.byte '$@'

doc/raql/%.ramen: doc/gen_doc.byte
	doc/gen_doc.byte '$@'

# There is one ramen file per test file:
doc/raql/%.success: doc/raql/%.test doc/raql/%.ramen src/ramen
	@echo 'Running doc test $(basename $< .test)'
	@$(RM) '$@'
	RAMEN_DESSSER_CODE_GENERATOR=never \
	RAMEN_OPTIMIZATION_LEVEL=3 \
	src/ramen test --bundle-dir=bundle '$<' --keep && touch '$@'

doc-check: $(addsuffix .success, $(basename $(GENERATED_DOC_TESTS)))

# Also that one once instrumentation is available from within ramen again:
# examples/benchmarks/comms.x \

RAMEN_FUNC_TESTS = $(wildcard tests/func/*.test)
RAMEN_ALERTER_TESTS = $(wildcard tests/alerter/*.test)

%.x: \
		%.ramen \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_DIR)/include/dessser \
		src/ramen \
		src/codegen.cmxa
	@echo 'Compiling ramen program $@'
	RAMEN_CONFSERVER= src/ramen compile --bundle=bundle -L . -L src -L tests/func '$<' -o '$@'

%.x: \
		%.alert \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_DIR)/include/dessser \
		src/ramen \
		src/codegen.cmxa
	@echo 'Compiling ramen program $@'
	RAMEN_CONFSERVER= src/ramen compile --bundle=bundle -L . -L src -L tests/func '$<' -o '$@'

%.x: \
		%.pivot \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_DIR)/include/caml \
		$(BUNDLE_DIR)/include/dessser \
		src/ramen \
		src/codegen.cmxa
	@echo 'Compiling ramen program $@'
	RAMEN_CONFSERVER= src/ramen compile --bundle=bundle -L . -L src -L tests/func '$<' -o '$@'

# Special generated test to check the speed of CSV parsing:

tools/gen_reader_test.opt: src/codegen.cmxa tools/gen_reader_test.ml
	@echo 'Compiling $@'
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -linkpkg -package cmdliner,batteries,binocle,dessser,ppp,qcheck,syslog $^ -o '$@'

tests/func/generated.type: tools/gen_reader_test.opt
	@echo 'Generating a random type for CSV reader speed test'
	@tools/gen_reader_test.opt type --max-depth=3 --format=CSV > '$@.tmp' && mv '$@.tmp' '$@'

tests/func/generated.ramen: tests/func/generated.type tools/gen_reader_test.opt
	@echo 'Generating a random CSV reader'
	@tools/gen_reader_test.opt reader --format=CSV --files=fixtures/generated.csv "$$(cat $<)" > '$@.tmp' &&\
	 echo >> '$@.tmp' &&\
	 echo 'DEFINE counter AS SELECT *, SUM globally 1 AS count FROM reader;' \
	   >> '$@.tmp' &&\
	 mv '$@.tmp' '$@'

tests/func/fixtures/generated.csv: tests/func/generated.type tools/gen_reader_test.opt
	@echo 'Generating a random CSV file'
	@tools/gen_reader_test.opt data --format=CSV --length=100000 "$$(cat $<)" > '$@.tmp' && mv '$@.tmp' '$@'

tests/func/generated.success: tests/func/generated.test tests/func/fixtures/generated.csv tests/func/generated.ramen

FORCED_DESSSER = \
	;any_ext;basename;basic_aggr;bits;\
	;case;casts;changed;char;count;count_lines;\
	;fit;from;fun_with_funcs;\
	;generated;gets;globals_function;globals_program;groups;\
	;in;kahan_sum;lag;list_aggr;local_state_in_where_slow;\
	;min_max;nan_vs_null;nulls;peek;port_scan;previous;rowbinary;\
	;sample;simplest;simplest_aggr;sort;stress;strings;top_expr;tumbling;

# FIXME: Missing deps on some sources. `ramen test -MM` should output those.
tests/func/%.success: tests/func/%.test src/ramen
	@echo 'Running RaQL test $(basename $< .test)'
	@$(RM) '$@'
	RAMEN_DESSSER_CODE_GENERATOR=$(if $(findstring ;$(notdir $(basename $< .test));,$(FORCED_DESSSER)),force,never) \
	RAMEN_OPTIMIZATION_LEVEL=3 \
	src/ramen test --bundle-dir=bundle '$<' && touch '$@'

tests/alerter/%.success: tests/alerter/%.test src/ramen
	@echo 'Running alerter test $(basename $< .test)'
	@$(RM) '$@'
	src/ramen test-alert '$<' && touch '$@'

func-check: \
	$(RAMEN_FUNC_TESTS:.test=.success) \
	$(RAMEN_ALERTER_TESTS:.test=.success)

# Order does matter:
COMPTEST_PROGRAMS = \
	tests/programs/nonreg_0_0.ramen \
	tests/programs/nonreg_0_1.alert \
	tests/programs/nonreg_0_2.alert \
	tests/programs/nonreg_1394.ramen \
	tests/programs/nullability_0_0.ramen \
	tests/programs/nullability_0_1.alert

comp-check: \
		src/ramen \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(COMPTEST_PROGRAMS)
	@echo 'Checking compilation of predefined programs'
	@set -e; \
	for f in $(COMPTEST_PROGRAMS); do \
	  echo "  Compiling $$f..." ;\
	  RAMEN_CONFSERVER= src/ramen compile --quiet --bundle=bundle -L tests/programs "$$f" ;\
	done ;\
	echo "\033[1;32mSUCCESS\033[0m"

err-check: \
		src/ramen \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_LIBORC) \
		$(wildcard tests/errors/*.ramen) \
		$(wildcard tests/errors/*.err)
	@echo 'Running parsing/typing error tests'
	@for f in $(wildcard tests/errors/*.ramen); do \
	  t=$$(mktemp) ;\
	  RAMEN_CONFSERVER= src/ramen compile --quiet --bundle=bundle -L tests/errors "$$f" 2>"$$t" >/dev/null ;\
	  if ! diff -q "$$f.err" "$$t" ; then \
	    echo "\033[1;31mFAILURE\033[0m: $$f" ;\
	    exit 1 ;\
	  fi ;\
	  $(RM) "$$t" ;\
	done ;\
	echo "\033[1;32mSUCCESS\033[0m"

RAMEN_ARCHIVIST_TESTS = $(wildcard tests/archivist/*.allocs)

arc-check: src/ramen $(RAMEN_ARCHIVIST_TESTS)
	@echo 'Running storage allocation tests'
	@echo 'TODO: make it possible to upload the stats file in the confserver'

orc-check: src/orc/orc_writer $(wildcard tests/orc/*.type) $(wildcard tests/orc/*.data)
	@echo 'Checking ORC writes...'
	@failed="" ;\
	 for t in $(wildcard tests/orc/*.type); do \
	   base="$$(basename $$t .type)" ;\
	   echo "  Checking $$base" ;\
	   typ=$$(cat "$$t") ;\
	   data="$$(dirname $$t)/$$base.data" ;\
	   writer="/tmp/$$base" ;\
	   orc="/tmp/$$base.orc" ;\
	   csv="/tmp/$$base.csv" ;\
	   if ! (\
	     src/orc/orc_writer "$$writer" "$$typ" &&\
	     "$$writer" write "$$orc" < "$$data" &&\
	     "$$writer" read  "$$orc" > "$$csv" ;\
	   ) then \
	     echo "\033[1;31mFAILURE\033[0m: Cannot create CSV file for $$base" ;\
	     failed="$$failed $$base" ;\
	   else \
	     if diff -q "$$data" "$$csv"; then \
	       echo "\033[1;32mSUCCESS\033[0m" ;\
	     else \
	       echo "\033[1;31mFAILURE\033[0m: $$data and $$csv differ:" ;\
	       diff "$$data" "$$csv" ;\
	       failed="$$failed $$base" ;\
	     fi ;\
	   fi ;\
	 done ;\
	 if test -n "$$failed"; then \
	   echo "\033[1;31mFAILURE\033[0m:$$failed" ;\
	   exit 1 ;\
	 fi

LINKED_FOR_BENCH = \
	src/RamenHelpersNoLog.ml \
	src/RamenLog.ml \
	src/RamenName.ml \
	src/RamenConstsExitCodes.ml \
	src/RamenConsts.ml \
	src/RamenAtomic.ml \
	src/RamenHelpers.ml \
	src/RamenVersions.ml \
	src/RamenFiles.ml \
	src/RamenExperiments.ml \
	src/RamenRaqlError.ml \
	src/RamenRaqlWarning.ml \
	src/RamenParsing.ml \
	src/RamenIpv4.ml \
	src/RamenIpv6.ml \
	src/HeavyHitters.ml \
	src/RamenBloomFilter.ml \
	src/RamenSampling.ml \
	src/RamenHeap.ml \
	src/CodeGenLib.ml

benchmarks.opt: \
		src/libringbuf.a \
		$(filter %.cmx,$(LINKED_FOR_BENCH:.ml=.cmx))
	$(OCAMLOPT) $(OCAMLOPTFLAGS) \
		-package batteries,benchmark,binocle,dessser,lacaml,parsercombinator,ppp,stdint,syslog \
		-linkpkg -cclib -lringbuf $(filter %.cmx, $^) src/benchmarks.ml -o '$@'

bench: benchmarks.opt
	./benchmarks.opt

# Installation

install: $(INSTALLED) install-bundle
	ocamlfind install ramen $(INSTALLED_LIB) META
	@echo 'Installing binaries into $(bin_dir)'
	install -d '$(bin_dir)'
	install $(INSTALLED_BIN) '$(bin_dir)/'
ifdef STRIP_BIN
	for f in $(INSTALLED_BIN); do \
	   strip '$(bin_dir)'/$$(basename $$f) || true ;\
	done
endif

# We need ocamlfind to find ramen package before we can install the lib bundle.
# Therefore we simply build it as a separate, optional step (that's only
# required if you intend to use the embedded compiler).
install-bundle: bundle
	@echo 'Installing libraries bundle into $(DESTDIR)$(lib_dir)'
	install -d '$(DESTDIR)$(lib_dir)'
	cp -r '$(BUNDLE_DIR)' '$(DESTDIR)$(lib_dir)/'

install-examples:
	@echo 'Installing examples into $(DESTDIR)$(sample_dir)'
	install -d '$(DESTDIR)$(sample_dir)'
	cd examples &&\
	 find . -type f -name '*.ramen' \
	   -exec sh -c 'mkdir -p '$(DESTDIR)$(sample_dir)'/$$(dirname {})' \; \
	   -exec sh -c 'cp {} '$(DESTDIR)$(sample_dir)'/$$(dirname {})' \;

install-systemd:
	@echo 'Installing systemd configuration into $(DESTDIR)$(systemd_dir)'
	install -d '$(DESTDIR)$(systemd_dir)'
	install -d '$(DESTDIR)$(sysconf_dir)'
	cp systemd/*.target systemd/*.service '$(DESTDIR)$(systemd_dir)'
	cp systemd/ramen '$(DESTDIR)$(sysconf_dir)'

uninstall: uninstall-bundle
	@echo 'Uninstalling binaries'
	# In case the bundle has been installed there, which would cause
	# `ocamlfind remove` to fail:
	$(RM) -r $(shell ocamlfind query ramen)/bundle
	ocamlfind remove ramen
	$(RM) '$(bin_dir)/ramen'

uninstall-bundle:
	@echo 'Uninstalling libraries bundle'
	$(RM) -r '$(DESTDIR)$(lib_dir)/$(BUNDLE_DIR)'

reinstall:
	$(MAKE) uninstall && \
	$(MAKE) install

# Debian package

deb: ramen.$(VERSION).deb

tarball: ramen.$(VERSION).tgz

ramen.$(VERSION).deb: \
		$(PACKAGED_BIN) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_LIBORC) \
		debian.control
	@echo 'Building debian package $@'
	$(RM) -r debtmp
	install -d debtmp/usr/bin
	install $(PACKAGED_BIN) debtmp/usr/bin
ifdef STRIP_BIN
	for f in $(PACKAGED_BIN); do strip debtmp/usr/bin/$$(basename $$f); done
endif
	$(MAKE) DESTDIR=$(CURDIR)/debtmp sample_dir=/var/lib/ramen/examples install-examples
	$(MAKE) DESTDIR=$(CURDIR)/debtmp lib_dir=/var/lib/ramen install-bundle
	$(MAKE) DESTDIR=$(CURDIR)/debtmp systemd_dir=/lib/systemd/system install-systemd
	mkdir -p debtmp/DEBIAN
	cp debian.control debtmp/DEBIAN/control
	chmod -R a+x debtmp/usr
	fakeroot dpkg --build debtmp
	mv debtmp.deb '$@'
	$(RM) -r debtmp

ramen.$(VERSION).tgz: \
		$(PACKAGED_BIN) \
		$(BUNDLE_DIR)/ramen/codegen.a \
		$(BUNDLE_LIBORC)
	@echo 'Building tarball $@'
	$(RM) -r tmp/ramen
	install -d tmp/ramen
	install $(PACKAGED_BIN) tmp/ramen/
	install @Z3@ tmp/ramen/
ifdef STRIP_BIN
	for f in $(PACKAGED_BIN); do strip tmp/ramen/$$(basename $$f); done
endif
	chmod -R a+x tmp/ramen/*
	$(MAKE) DESTDIR=$(CURDIR)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-examples
	$(MAKE) DESTDIR=$(CURDIR)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-bundle
	$(MAKE) DESTDIR=$(CURDIR)/tmp/ramen/ lib_dir=/ sample_dir=/examples systemd_dir=/systemd sysconf_dir=/defaults install-systemd
	tar c -C tmp ramen | gzip > $@
	$(RM) -r tmp

# Docker images:
# - docker builds the ramen docker image;
# - docker-dev builds the docker-dev image.

docker: docker/Dockerfile
	@echo 'Building docker image'
	$(DOCKER_BUILD) --squash -t rixed/ramen:latest -f '$<' docker/
	@echo 'Pushing to local hub as localhost:5000/ramen'
	docker tag rixed/ramen localhost:5000/ramen
	docker push localhost:5000/ramen

# docker-push target will tag and push the images:
docker-push:
	@echo 'Tagging and uploading latest docker image to v$(VERSION)'
	docker tag rixed/ramen:latest rixed/ramen:v$(VERSION)
	docker push rixed/ramen:latest
	docker push rixed/ramen:v$(VERSION)

DISTRIB_TAGS = \
	debian:11.2-slim,bullseye \
	debian:10.11-slim,buster

docker-dev: docker/Dockerfile-dev
	@for distrib_tag in $(DISTRIB_TAGS) ; do \
	  distrib=`echo $$distrib_tag | cut -d, -f1` ;\
	  tag=`echo $$distrib_tag | cut -d, -f2` ;\
	  echo 'Building ramen-dev docker image from '$$distrib ;\
	  $(DOCKER_BUILD) -t rixed/ramen-dev:$$tag \
	                  -f docker/Dockerfile-dev \
	                  --build-arg distrib=$$distrib docker/ ;\
	done

# docker-dev-push target will tag and push that images:
docker-dev-push:
	@echo 'Uploading docker-dev image(s)'
	 for distrib_tag in $(DISTRIB_TAGS) ; do \
	   tag=`echo $$distrib_tag | cut -d, -f2` ;\
	   docker push rixed/ramen-dev:$$tag ;\
	 done
	docker tag rixed/ramen-dev:bullseye rixed/ramen-dev:latest ;\
	docker push rixed/ramen-dev:latest

# The docker image is build from the debian package:
docker/ramen.$(VERSION).deb: ramen.$(VERSION).deb
	@echo 'Copying debian package into docker/'
	cp '$<' '$@'

# Also for the docker image only. docker-dev builds its own z3.
docker/z3: @Z3@
	@echo 'Copying z3 from system into docker/'
	cp '$<' '$@'

# Cleaning

clean-temp:
	@echo 'Cleaning ramen compiler temp files'
	for d in tests examples ; do\
	   find $$d -\( -name '*.cc' -o -name '*.ml' -o -name '*.cmx' \
	                -o -name '*.o' -o -name '*.annot' -o -name '*.cmt' \
	                -o -name '*.cmti' -o -name '*.x' -o -name '*.s' \
	                -o -name '*.cmi' -o -name '*.smt2' -o -name '*.info' -\) \
	            -delete ;\
	 done

clean-dist: clean clean-temp clean-dist-doc
	@echo 'Cleaning all build files'
	$(RM) doc/tutorial.html doc/manual.html doc/roadmap.html
	find tests -name '*.success' -delete
	$(RM) -r '$(BUNDLE_DIR)'
	$(RM) -r debtmp
	$(RM) -r tmp
	$(RM) -r submodules/orc
	$(RM) ramen.*.deb ramen.*.tgz
	$(RM) $(PAGES)
	$(RM) META
	$(RM) src/country_of_ip/db_v4.c src/country_of_ip/db_v6.c
	$(RM) IpToCountry.csv.gz IpToCountry.6R.csv.gz

clean: clean-dessserc-gen clean-doc
	@echo 'Cleaning result'
	$(RM) src/*.s src/*.annot src/*.cmt src/*.cmti src/*.o
	$(RM) *.opt src/all_tests.* perf.data* gmon.out
	$(RM) src/ringbuf/*.o src/orc/*.o
	$(RM) src/*.cmx src/*.cmxa src/*.cmxs src/*.cmi src/*.cmo
	$(RM) src/orc/*.cmx src/orc/*.annot src/orc/*.cmt src/orc/*.cmxs src/orc/*.cmi
	$(RM) src/oUnit-anon.cache src/qtest.targets.log
	$(RM) src/*.opt src/*.byte
	$(RM) src/RamenDepLibs.ml src/RamenSubcommands.ml
	$(RM) src/RamenFileNotify.ml src/RamenCompilConfig.ml
	$(RM) src/ramen src/codegen.cmxa src/libringbuf.a src/liborchelp.a
	$(RM) tools/*.opt tools/*.s tools/*.annot tools/*.cmt tools/*.cmti
	$(RM) tools/*.o tools/*.cmx tools/*.cmi
	$(RM) src/libcollectd.a src/libnetflow.a src/codegen.a
	$(RM) src/libcountry.a IpToCountry.csv IpToCountry.6R.csv
	$(RM) tests/func/generated.type tests/func/fixtures/generated.csv tests/func/generated.ramen
	$(RM) debian.control

clean-dessserc-gen:
	# Do not delete raql_type.ml*!
	$(RM) $(patsubst %.type, %.ml, $(filter %.type, $(TYPE_SOURCES)))

authn: src/RamenAuthn.cmx
	$(OCAMLOPT) $(OCAMLOPTFLAGS) -package batteries,sodium -linkpkg $(filter %.cmx, $^) -o '$@'
