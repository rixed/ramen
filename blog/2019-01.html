<html>
  <head>
    <meta charset="utf-8">
    <base href="https://rixed.github.io/ramen/">
    <link rel="stylesheet" href="style.css" type="text/css" media="screen">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <title>Ramen Documentation</title>
  </head>
<body>

<div id="header">
  <p class="title">Ramen Documentation</p>
  <p>
    <a class="github-cat" href="https://github.com/rixed/ramen">
      <svg class="octicon" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.7 5.34c.13-.32.55-1.59-.13-3.31 0 0-1.05-.33-3.44 1.3-1-.28-2.07-.32-3.13-.32s-2.13.04-3.13.32c-2.39-1.64-3.44-1.3-3.44-1.3-.68 1.72-.26 2.99-.13 3.31C.49 6.21 0 7.33 0 8.69 0 13.84 3.33 15 7.98 15S16 13.84 16 8.69c0-1.36-.49-2.48-1.3-3.35zM8 14.02c-3.3 0-5.98-.15-5.98-3.35 0-.76.38-1.48 1.02-2.07 1.07-.98 2.9-.46 4.96-.46 2.07 0 3.88-.52 4.96.46.65.59 1.02 1.3 1.02 2.07 0 3.19-2.68 3.35-5.98 3.35zM5.49 9.01c-.66 0-1.2.8-1.2 1.78s.54 1.79 1.2 1.79c.66 0 1.2-.8 1.2-1.79s-.54-1.78-1.2-1.78zm5.02 0c-.66 0-1.2.79-1.2 1.78s.54 1.79 1.2 1.79c.66 0 1.2-.8 1.2-1.79s-.53-1.78-1.2-1.78z"></path></svg>
    <span class="github-link">to source code</span></a>
  </p>
</div>

<script type="application/json" class="js-hypothesis-config">{ "showHighlights": "whenSidebarOpen" }</script>
<script src="https://hypothes.is/embed.js" async></script>

<div id="menu">
  <ul>
            <li>
      <a class="" href="index.html">Overview</a>
        </li>
          <li>
      <a class="" href="download.html">Downloading</a>
        </li>
          <li>
      <a class="" href="build.html">Building</a>
        </li>
          <li>
      <a class="" href="tutorials.html">Tutorials</a>
        </li>
          <li>
      <a class="" href="design.html">Design</a>
        </li>
          <li>
      <a class="" href="roadmap.html">Roadmap</a>
        </li>
          <li>
      <a class="" href="man.html">Command line reference</a>
        </li>
          <li>
      <a class="" href="language_reference.html">Language reference</a>
        </li>
          <li>
      <a class="" href="glossary.html">Glossary</a>
        </li>
          <li>
      <a class="" href="blog.html">Blog posts</a>
          <ul>
              <li><a class="" href="blog/2018-12.html">One-liners</a></li>
              <li><a class="" href="blog/2019-01.html">Projection of deep compound types</a></li>
              <li><a class="" href="blog/2019-02.html">Benchmark against KSQL</a></li>
              <li><a class="" href="blog/2019-03.html">One degree of scale</a></li>
              <li><a class="" href="blog/2019-05.html">Who need two different message queues?</a></li>
              <li><a class="" href="blog/2019-07.html">Does C++ devs worth more than web devs?</a></li>
              <li><a class="" href="blog/2019-12.html">Walk through deep field selection</a></li>
              <li><a class="" href="blog/2019-12_.html">Walk through replays</a></li>
              <li><a class="" href="blog/2022-02.html">What happened those last two years?</a></li>
            </ul>
        </li>
    </ul>
</div>

<div id="page">

<h1>Projection of deep compound types</h1>
<p class="date">2019-01-16</p>

<h2>Compound types?</h2>

<p>Compound types are types build from other types. The basic, nearly universal compound types are lists, arrays, tuples and records. For instance an array of integers is a compound type; a list of arrays of boolean and strings is also a compound type. More sophisticated compound types can be devised: sets, maps, sum types, objects,&nbsp;... but lists and records seems to be the most important, judging by the popularity of JSON which offers only those two.</p>

<p>Ramen allows to group values into <i>vectors</i> (ie. fixed length arrays), <i>lists</i> (dynamically sized arrays) and <i>tuples</i> (ordered set of values of different types); But not records. Records are nothing more than tuples with named fields, so I though records and the required associated syntax could be added any time later easily.</p>

<h2>Software grows in cycles.</h2>

<p>The job of a programmer is twofold:</p>

<ul>
<li>On one hand, adding LOCs to grow a code base; This is the easy task that is rarely conflictual.</li>
<li>On the other hand, pruning and reorganizing that code which have grown organically in several conflictual directions, in order to strengthen a particular desired evolution; this is the part that may involve conflicts (first with the authors of the code that's being pruned and then with the management who doubt the value of reorganizing code)</li>
</ul>

<p>The evolution of data types in Ramen followed this cycle.</p>

<p>Initially, there were only scalar types, except for the input and output of functions which were records. Those records were thus treated specially. For instance, one can write <code>in.foo</code> to access the <code>foo</code> field of the input event, but it was not possible, beside the SELECT projector, to create ones own record type.</p>

<p>Then came a day when we wanted some operators to accept or return compound types, such as the <code>histogram</code> or <code>sample</code> operations which return a vector. So lists, tuples and vectors were added, with the corresponding syntax to construct them and access their components. Not records though, as the desired syntax (<code>value.subfield</code>) was already in use to access the individual fields of the input and output events.</p>

<p>Ideally, records should be normal compound types with corresponding syntax for construction and field access; And functions should input and output values of any types. Ramen would be simpler and more flexible. And it would be simpler to implement storing archives in ORC files.</p>

<p>So now is the time to implement records and do away with the special type and syntax for manipulating events. But this turned out a longer journey than expected.</p>

<h2>The burden of hierarchies</h2>

<p>It is not rare to encounter a relational data model mixed with a hierarchical data model. Who have never stored a JSON value in a text column, out of convenience?</p>

<p>This poses a problem though: a relational database knows how to project away unused columns but not how to project away unused branches of deep hierarchical values. And Ramen was no different: If a function selects a column from another, only that column is going to be transfered between the two functions; But if that column is a vector and only the first item of that vector is used, the whole vector is still going to be passed.</p>

<p>In a normal programming language one would likely pass a pointer to the structure to avoid that copy. But when the called function does not share the same memory then passing an address is no longer an option.</p>

<p>We could live with it for vectors and lists, as the use case of selecting just one item and discarding every others is probably rare. But for records this is much more likely to happen. If a function outputs a field named <code>client</code> with this value (here in JSON-like syntax):</p>

<pre>
{
  "round_trip_time": {
    "min": 0.123, "max": 0.234, "avg": 0.201,
    "95th": 0.202, "99th": 0.229
  },
  "time_to_first_byte": {
    "min": 0.21, "max": 1.517, "avg": 0.541,
    "95th": 1.493, "99th": 1.512
  }
}
</pre>

<p>...then that whole data structure is going to be sent to a child function even if that child only ever look at <code>client.round_trip_time.avg</code>.</p>

<p>This is even worse than it looks: since we would like events to be normal values (of type record), if we cannot project away unused branches of a record that means we don't know how to project away unused columns any longer!</p>

<p>It would be a shame that the convenience of records be offset by the runtime cost. So projection has to be made smarter.</p>

<p>First, Ramen must look in depth what fields and subfields (and/or what indices) are actually used by a consumer, and then instruct the producer that it must send only those elements. Currently, a flat bit mask with one bit per field is used to describe what to send in the output specification files. This mask needs to become hierarchical. And the serialization and de-serialization code needs to follow this hierarchy when coding/decoding passed events. Only then will it become possible to have large user defined records for free.</p>

<p>This is a bigger change than adding a syntax to access tuple fields, but it is a nice optimisation. Actually, event vectors, list and tuples will benefit from it.</p>

</div>
</body>
</html>
